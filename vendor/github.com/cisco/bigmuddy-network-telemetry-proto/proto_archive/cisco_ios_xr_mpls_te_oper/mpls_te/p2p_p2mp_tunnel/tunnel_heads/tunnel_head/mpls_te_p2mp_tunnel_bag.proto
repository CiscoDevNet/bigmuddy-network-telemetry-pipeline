// Copyright (c) 2015, Cisco Systems
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file is autogenerated
//
// The following edits are possible, without affecting the validity of the
// file:
//
//  * Fields may be renamed.
//  * Fields may be deleted.
//  * The unique numbered tag for a field may be changed, provided that
//    the ordering of tags for fields within a message is preserved.
//  * Message types may be renamed.
//  * Message types may be deleted (if all fields that reference them
//    have been deleted).
//
// All Cisco message and field extensions must be preserved (except when the
// field itself is being deleted).

syntax = "proto3";

package cisco_ios_xr_mpls_te_oper.mpls_te.p2p_p2mp_tunnel.tunnel_heads.tunnel_head;

// P2MP tunnel data
message mpls_te_p2mp_tunnel_bag_KEYS {
    string tunnel_name = 1;
}

message mpls_te_p2mp_tunnel_bag {
    // TRUE if Role is Standby, Active otherwise
    bool role_standby = 50;
    // Interface handle of the associated tunnel
    string tunnel_interface_name = 51;
    // Configuration data
    mpls_te_p2mp_tun_cfg_bag config = 52;
    // Administrative State
    string admin_state = 53;
    // Operational State
    string operational_state = 54;
    // Counters for operational state changes
    uint32 operational_state_changes = 55;
    // Signaled Name
    string signaled_name = 56;
    // The reason why failure occurred
    string fail_reason = 57;
    // Count of up destinations
    uint32 destination_up_count = 58;
    // Count of disabled destinations
    uint32 destination_disabled_count = 59;
    // Count of down destinations
    uint32 destination_down_count = 60;
    // Destinations array
    repeated mpls_te_p2mp_dest destinations = 61;
    // Current LSP
    mpls_te_p2mp_lsp tunnel_current_lsp = 62;
    // Reopt LSP
    mpls_te_p2mp_lsp reoptimized_p2_mp_lsp = 63;
    // Standby LSP
    mpls_te_p2mp_lsp tunnel_standby_lsp = 64;
    // Standby Reopt LSP
    mpls_te_p2mp_lsp reoptimized_standby_p2_mp_lsp = 65;
    // Restoration LSP
    mpls_te_p2mp_lsp tunnel_restoration_lsp = 66;
    // Delay Clean PP LSP
    mpls_te_p2mp_lsp delay_clean_pp_lsp = 67;
    // Cleaned LSP
    mpls_te_p2mp_lsp cleaned_lsp = 68;
    // Backup hold-down timer remaining time in seconds
    uint32 re_opt_hold_down_timer_remaining = 69;
    // Bandwidth Requested
    uint32 bandwidth_requested = 70;
    // The requested bandwidth type
    string bandwidth_type = 71;
    // Node Protection Enabled or Disabled
    bool is_node_protected = 72;
    // BW Protection Enabled or Disabled
    bool is_bandwidth_protect = 73;
    // Tunnel recovering
    bool tunnel_recovering = 74;
    // ReroutePending
    bool reroute_pending = 75;
    // Explicit-path inuse by the current LSP has been modified
    bool explicit_path_change = 76;
    // Path-Option inuse by the current LSP has been modified
    bool path_option_change = 77;
    // AffinityFailureReoptDisabled
    bool affinity_failure_reopt_disabled = 78;
    // AffinityFailureReoptTimeRemained
    uint32 affinity_failure_reopt_time_remained = 79;
    // Affinity Failure LSP tear down time remaining
    uint32 affinity_failure_delayed_tear_time_remained = 80;
    // Path invalidation time remaining
    uint32 invalidation_time_remained = 81;
    // True if tunnel is in drop mode
    bool drop_mode = 82;
    // IGP Auto route announce enabled
    bool auto_route = 83;
    // IGP forwarding adjacency enabled
    bool forwarding_adjacency = 84;
    // The specified loadsharing for the tunnel
    uint32 load_share_factor = 85;
    // Loadsharing type
    string load_share_type = 86;
    // Time at which the tunnel was created
    uint32 create_time = 87;
    // Time in seconds since the tunnel was up
    uint32 uptime = 88;
    // The path selection metric
    string metric_type = 89;
    // The path selection tiebreaker type
    uint32 tiebreaker_type = 90;
    // Describes how the path selection tiebreaker was specified: default, globally set, or per interface
    string tiebreaker_qualifier = 91;
    // Describe how the metric was specified: default, globally set, or per interface
    string metric_qualifier = 92;
    // Is Hop-limit ignored
    bool is_hop_limit_ignore = 93;
    // Hop-limit ignored reason
    string hop_limit_ignored_reason = 94;
    // Indicates outbound FRR state
    string outbound_frr_state = 95;
    // Indicates the protocol and area used to find Outgoing ERO
    string area_id = 96;
    // P2P specific info
    mpls_te_p2p_info_bag p2_p_info = 97;
    // Failure reason for PCE-based tunnels
    string pce_fail_reason = 98;
    // SNMP index for interface
    uint32 snmp_index = 99;
    // Tunnel history
    mpls_te_tunnels_history_bag history = 100;
    // Path Protect Info
    mpls_te_pp_info path_protection = 101;
    // Indicates whether this tunnel spans multiple areas.
    bool is_inter_area_tunnel = 102;
    // Autobackup Information
    mpls_te_autobackup_info auto_backup = 103;
    // Indicates whether this is an automatically generated backup tunnel
    bool is_auto_backup = 104;
    // Automesh Information
    mpls_te_automesh_info auto_mesh = 105;
    // Indicates whether this is an automatic PCC tunnel
    bool is_auto_pcc = 106;
    // Auto-PCC Information
    mpls_te_autopcc_info auto_pcc = 107;
    // Indicates whether this tunnel is delegated to a PCE server or not
    bool is_pce_delegated = 108;
    // PCE Delegation information
    mpls_te_pce_delegation_info pce_delegation = 109;
    // AttributeSet name
    string tunnel_attribute_set_name = 110;
    // AttributeSet type
    string tunnel_attribute_set_type = 111;
    // Tunnel head soft preemption info. This is NULL if soft preemption is not configured
    mpls_te_soft_preemption_tunnel_info soft_preemption = 112;
    // WDM-UNI tunnel data. Only exists for WDM-UNI tunnels
    mpls_te_mgmt_wdm_uni_tunnel_info wdm_uni_tunnel = 113;
    // Transport tunnel data. Only exists for Transport tunnels
    mpls_te_transport_tunnel_info transport_tunnel_info = 114;
    // BFD session info. This is NULL if BFD is not configured
    mpls_te_tunnel_bfd_info bfd_info = 115;
    // OTN bidir info
    mpls_te_tunnel_otn_bidir_info otn_bidir = 116;
    // Bidir info
    mpls_te_tunnel_bidir_info bidir = 117;
    // Configured XRO attribute-set name
    string xro_attribute_set_name = 118;
    // XRO attribute-set
    mpls_te_attribute_set xro_attribute_set = 119;
    // TE tunnel convergence related information
    te_vif_convergence_info te_tunnel_convergence = 120;
    // True for passive tunnel
    bool is_passive = 121;
    // Passive tunnel name
    string passive_tunnel_name = 122;
    // Flex Info
    mpls_te_tunnel_flex_info flex_info = 123;
    // True, if binding label exists
    bool binding_label_exists = 124;
    // Binding Label
    uint32 binding_label = 125;
    // Termination destination ifindex
    uint32 last_hop_ifindex = 126;
    // Indicates whether this tunnel is named
    bool is_named = 127;
    // Lsp-wrap Protection enabled
    bool lsp_wrap_protection_enabled = 128;
    // Lsp-wrap label value
    uint32 lsp_wrap_label = 129;
    // True for tunnel head
    bool is_interface = 130;
    // Time in seconds since the last path change
    uint32 last_path_change = 131;
    // Persistent forwarding statistics for number of bytes. Clear counters will not reset the counter
    uint64 persistent_bytes = 132;
    // Persistent forwarding statistics for Number of packets. Clear counters will not reset the counter
    uint64 persistent_packets = 133;
}

// The value of the counter
message rsvp_ng_api_stats_entry_bag {
    // Count
    uint64 count = 1;
}

// Collection of stats for a given event type
message rsvp_ng_api_stats_bag {
    // The CTX event of the stats
    string ctx_event_type = 1;
    // The ctrl event of the stats
    string ctrl_event_type = 2;
    // Number of scheduled events
    rsvp_ng_api_stats_entry_bag scheduled = 3;
    // Number of transmitted events
    rsvp_ng_api_stats_entry_bag tx = 4;
    // Number of received events
    rsvp_ng_api_stats_entry_bag rx = 5;
    // Number of dropped Tx events
    rsvp_ng_api_stats_entry_bag drop_tx = 6;
    // Number of dropped Rx events
    rsvp_ng_api_stats_entry_bag drop_rx = 7;
    // Number of postponed TX events
    rsvp_ng_api_stats_entry_bag postponed_tx = 8;
}

// Information about the event for an API CTX
message rsvp_ng_api_ctx_event_bag {
    // The event type
    string type = 1;
    // Producer summary replay ID
    uint64 producer_summary_replay_id = 2;
    // TRUE if this event is sent
    bool is_sent = 3;
    // Age the event (in sec)
    uint32 age = 4;
    // Reason if thus event is filtered during transmission
    string filter_reason = 5;
}

// CTX History Buffer
message rsvp_ng_api_ctx_history {
    // Event Timestamp
    uint32 timestamp = 1;
    // Event Type
    string event_type = 2;
    // Event Data
    repeated uint32 event_data = 3;
}

// Bag representing the CTX in the RSVP API
message rsvp_ng_api_ctx_bag {
    // Producer summary replay ID
    uint64 producer_summary_replay_id = 1;
    // Producer summary replay base ID
    uint32 producer_summary_replay_base_id = 2;
    // Consumer summary replay ID
    uint64 consumer_summary_replay_id = 3;
    // Consumer summary replay base ID
    uint32 consumer_summary_replay_base_id = 4;
    // Flags
    uint32 flags = 5;
    // Origin of this CTX
    string origin = 6;
    // Statistics
    repeated rsvp_ng_api_stats_bag statistics = 7;
    // Events
    repeated rsvp_ng_api_ctx_event_bag events = 8;
    // History
    repeated rsvp_ng_api_ctx_history history = 9;
    // Slave Producer summary replay ID
    uint64 slave_producer_summary_replay_id = 10;
    // Slave Consumer summary replay ID
    uint64 slave_consumer_summary_replay_id = 11;
}

// RSVP ERO IPV4 subobject
message rsvp_mgmt_ero_ipv4_subobj {
    // ERO Entry Is Strict
    bool is_strict_route = 1;
    // The ERO IPV4 Address
    string ero_address = 2;
    // ERO Prefix Length
    uint32 prefix_length = 3;
}

// RSVP ERO UNNUM subobject
message rsvp_mgmt_ero_unnum_subobj {
    // ERO Entry Is Strict
    bool is_strict_route = 1;
    // The Interface ID in ERO
    uint32 ero_interface_id = 2;
    // The Router ID in ERO
    string ero_router_id = 3;
    // Status of ERO
    string status = 4;
}

// Union of the different RSVP ERO types
message rsvp_mgmt_ero_subobj {
    string ero_type = 1;
    // IPV4 ERO Sub Object
    rsvp_mgmt_ero_ipv4_subobj ipv4_ero_sub_object = 2;
    // Unnumbered ERO Sub Object
    rsvp_mgmt_ero_unnum_subobj unnumbered_ero_sub_object = 3;
}

// RSVP RRO IPV4 Subobject Flags
message rsvp_mgmt_rro_ipv4_subobj_flags {
    // Local Protection Available
    bool is_protection_available = 1;
    // Local Protection In Use
    bool is_protection_in_use = 2;
    // Bandwidth Protection Available
    bool is_bandwidth_protected = 3;
    // Node Protection Available
    bool is_node_protection_available = 4;
    // Node ID In Use
    bool is_node_id = 5;
}

// RSVP RRO Label Subobject Flags
message rsvp_mgmt_rro_label_subobj_flags {
    // Label is Global across all interfaces
    bool is_global_label = 1;
}

// RSVP RRO UNNUMBERED Subobject Flags
message rsvp_mgmt_rro_unnumbered_subobj_flags {
    // Local Protection Available
    bool is_protection_available = 1;
    // Local Protection In Use
    bool is_protection_in_use = 2;
    // Bandwidth Protection Available
    bool is_bandwidth_protected = 3;
    // Node Protection Available
    bool is_node_protection_available = 4;
    // Node ID In Use
    bool is_node_id = 5;
}

// RSVP RRO IPV4 subobject
message rsvp_mgmt_rro_ipv4_subobj {
    // The RRO IPV4 Subobject Flags
    rsvp_mgmt_rro_ipv4_subobj_flags flags = 1;
    // The RRO IPV4 Address
    string rro_address = 2;
}

// RSVP RRO Label subobject
message rsvp_mgmt_rro_label_subobj {
    // The RRO Subobject Label Flags
    rsvp_mgmt_rro_label_subobj_flags flags = 1;
    // The RRO Subobject Label Value
    uint32 label = 2;
    // Is the RRO Subobject Label Variable Length
    bool is_label_variable_length = 3;
    // The RRO Subobject Variable Length Label
    repeated uint32 variable_length_label = 4;
}

// RSVP RRO Unnumbered subobject
message rsvp_mgmt_rro_unnumbered_subobj {
    // The RRO Subobject Unnumbered Flags
    rsvp_mgmt_rro_unnumbered_subobj_flags flags = 1;
    // The RRO Interface Address
    string interface_address = 2;
    // The RRO Interface ID
    uint32 interface_id = 3;
}

// RSVP RRO SRLG subobject
message rsvp_mgmt_rro_srlg_subobj {
    // The RRO Subobject SRLGs
    repeated uint32 srl_gs = 1;
}

// Union of the different RSVP RRO types
message rsvp_mgmt_rro_subobj {
    string rro_type = 1;
    // IPV4 RRO Sub Object
    rsvp_mgmt_rro_ipv4_subobj ipv4_rro_sub_object = 2;
    // Label RRO Sub Object
    rsvp_mgmt_rro_label_subobj label_rro_sub_object = 3;
    // Unnumbered RRO Sub Object
    rsvp_mgmt_rro_unnumbered_subobj unnumbered_rro_sub_object = 4;
    // SRLG RRO Sub Object
    rsvp_mgmt_rro_srlg_subobj srlg_rro_sub_object = 5;
}

// A sub-LSP FEC
message te_s2l_fec_t {
    // sub-LSP subgroup ID
    uint32 s2_l_fec_subgroup_id = 1;
    // LSP ID
    uint32 s2_l_fec_lsp_id = 2;
    // Tunnel ID
    uint32 s2_l_fec_tunnel_id = 3;
    // Extended tunnel ID
    string s2_l_fec_extended_tunnel_id = 4;
    // LSP source address
    string s2_l_fec_source = 5;
    // sub-LSP destination address
    string s2_l_fec_dest = 6;
    // P2MP ID
    uint32 s2_l_fec_p2_mp_id = 7;
    // Subgroup Originator
    string s2_l_fec_subgroup_originator = 8;
    // Session identifier (ctype)
    string s2_l_fec_c_type = 9;
    // VRF; currently only for GMPLS tunnels
    string s2_l_fec_vrf = 10;
}

// TE IPv4 unnumbered address type
message te_addr_type_ipv4_unnum {
    // IPv4 router ID
    string router_id = 1;
    // Interface index
    uint32 interface_index = 2;
}

message addr {
    string type = 1;
    // IPv4 address
    string ipv4_address = 2;
    // IPv4 unnumbered address
    te_addr_type_ipv4_unnum ipv4_unnumbered_address = 3;
}

message te_addr_t_ {
    // TE Address
    addr te_addr = 1;
}

// Egress Static UNI Info
message mpls_te_tunnel_egress_static_uni_info {
    // Egress Client Port of Tunnel
    te_addr_t_ egress_port = 1;
    // Local Termination Type
    string local_termination = 2;
    // Remote_uni_type
    string remote_uni_type = 3;
    // Termination Egress Client Port of Tunnel
    te_addr_t_ term_egress_port = 4;
}

// C-type-specific LSP FEC data
message te_lsp_fec_ctype_data_t {
    string fec_c_type = 1;
    // P2P LSP destination
    string p2_p_lsp_destination = 2;
    // P2MP ID
    uint32 fec_destination_p2_mp_id = 3;
}

// A LSP FEC
message te_lsp_fec_t {
    // LSP ID
    uint32 fec_lsp_id = 1;
    // Tunnel ID
    uint32 fec_tunnel_id = 2;
    // Extended tunnel ID
    string fec_extended_tunnel_id = 3;
    // Tunnel source address
    string fec_source = 4;
    // Destination or P2MP ID
    te_lsp_fec_ctype_data_t fec_destination_info = 5;
    // VRF; currently only for GMPLS tunnels
    string fec_vrf = 6;
}

// Affinity name constraints
message affinity_name_bag {
    // Constraint type
    uint32 constraint_type = 1;
    // Deprecated
    uint32 constraint_value = 2;
    // Deprecated
    uint32 forward_ref_value = 3;
    // Constraint value
    repeated uint32 constraint_extended_value = 4;
    // Reference bits for undefined affinity names
    repeated uint32 extended_forward_ref_value = 5;
}

// MPLS TE tunnel Affinity information
message mpls_te_tunnels_affinity_info {
    // The affinity bits (colors)
    uint32 affinity_bits = 1;
    // The affinity mask (colors)
    uint32 affinity_mask = 2;
    // Array of name based constratints currently applied to the tunnel
    repeated affinity_name_bag named_affinities = 3;
}

// Information about the Shared Risk Link Group
message mpls_srlg_info {
    // SRLG number
    uint32 shared_risk_group = 1;
    // SRLG name
    string srlg_name = 2;
}

// TE BFDOverLSP Counters
message mpls_te_bfd_lsp_counters {
    // The number of BFDOverLSP session create events
    uint32 session_create_events = 1;
    // The number of BFDOverLSP session up events
    uint32 session_up_events = 2;
    // The number of BFDOverLSP session creation failed events
    uint32 session_creation_failed_events = 3;
    // The number of BFDOverLSP session down events
    uint32 session_down_events = 4;
    // The number of BFDOverLSP session admin down events
    uint32 session_admin_down_events = 5;
    // The number of BFDOverLSP session gracefully delete events
    uint32 session_gracefully_delete_events = 6;
    // The number of BFDOverLSP session non gracefully delete events
    uint32 session_non_gracefully_delete_events = 7;
    // The number of BFDOverLSP session create timeout events
    uint32 session_create_timeout_events = 8;
    // The number of BFDOverLSP session replay events
    uint32 session_replay_events = 9;
}

// XRO IPv4 sub-object
message te_xro_subobj_ipv4 {
    // IPv4 address
    string address = 1;
    // Prefix length
    uint32 prefix_len = 2;
    // Attribute
    string attribute = 3;
    // Exclusion Type
    string exclusion_type = 4;
}

// XRO IPv6 sub-object
message te_xro_subobj_ipv6 {
    // IPv6 address
    string address = 1;
    // Prefix length
    uint32 prefix_len = 2;
    // Attribute
    string attribute = 3;
    // Exclusion Type
    string exclusion_type = 4;
}

// XRO unnumbered sub-object
message te_xro_subobj_unnum {
    // TE router-id
    string te_router_id = 1;
    // Interface ID
    uint32 interface_id = 2;
    // Attribute
    string attribute = 3;
    // Exclusion Type
    string exclusion_type = 4;
}

// XRO AS sub-object
message te_xro_subobj_as {
    // Autonomous System number
    uint32 as_number = 1;
}

// XRO SRLG sub-object
message te_xro_subobj_srlg {
    // SRLG ID
    uint32 srlg_id = 1;
    // Exclusion Type
    string exclusion_type = 2;
}

// XRO point-to-point LSP sub-object
message te_xro_subobj_p2p_lsp {
    // LSP FEC
    te_lsp_fec_t fec = 1;
    // Flag to indicate whether or not the lsp-id in the FEC is to be ignored
    bool ignore_lsp_id = 2;
    // Processing-node exception flag
    bool processing_node_exception = 3;
    // Penultimate-node exception flag
    bool penultimate_node_exception = 4;
    // Destination-node exception flag
    bool destination_node_exception = 5;
    // Exclusion Type
    string exclusion_type = 6;
}

// XRO sub-object union
message te_xro_subobj {
    string type = 1;
    // IPv4 sub-object
    te_xro_subobj_ipv4 ipv4_subobject = 2;
    // IPv6 sub-object
    te_xro_subobj_ipv6 ipv6_subobject = 3;
    // Unnumbered sub-object
    te_xro_subobj_unnum unnumbered_subobject = 4;
    // AS sub-object
    te_xro_subobj_as as_subobject = 5;
    // SRLG sub-object
    te_xro_subobj_srlg srlg_subobject = 6;
    // P2P LSP sub-object
    te_xro_subobj_p2p_lsp lsp_subobject = 7;
}

// XRO object
message te_xro {
    // List of XRO sub-objects
    repeated te_xro_subobj xro_subobjects = 1;
    // Mutual Diversity Flag
    bool mutual_diversity_flag = 2;
}

// Revert Schedule protection attribute set
message te_revert_sch_t {
    // Schedule name identifier
    bytes schedulename = 1;
    // Schedule time for reversion
    uint32 schedule_date = 2;
    // Schedule frequency for reversion
    string schedule_frequency = 3;
    // Duration for scheduled reversion
    uint32 duration = 4;
    // Max tries for scheduled reversion
    uint32 max_tries = 5;
}

// HASI ID Event
message hasi_id_event {
    // LocalID
    uint64 local_id = 1;
    // RemoteID
    uint64 remore_id = 2;
    // Time
    uint32 time = 3;
    // Count
    uint64 count = 4;
}

// HASI Slave Object ID events
message hasi_s_obj_id_events {
    // Create
    hasi_id_event create = 1;
    // Updates
    hasi_id_event updates = 2;
    // ApplicationSyncs
    hasi_id_event application_syncs = 3;
    // ApplicationNaks
    hasi_id_event application_naks = 4;
    // SummaryReplaySyncs
    hasi_id_event summary_replay_syncs = 5;
    // SummaryReplayNaks
    hasi_id_event summary_replay_naks = 6;
    // CacheNakRetries
    hasi_id_event cache_nak_retries = 7;
}

// HASI Slave Object Context
message hasi_s_object_ctx {
    // ObjectSyncID
    uint64 object_sync_id = 1;
    // ObjectType
    uint32 object_type = 2;
    // ObjectIdEvents
    hasi_s_obj_id_events object_id_events = 3;
}

// HASI Master Slave ID Events
message hasi_m_id_events {
    // ApplicationSyncs
    hasi_id_event application_syncs = 1;
    // ImplicitDeletes
    hasi_id_event implicit_deletes = 2;
    // ApplicationNaks
    hasi_id_event application_naks = 3;
    // SummaryReplaySyncs
    hasi_id_event summary_replay_syncs = 4;
    // SummaryReplayNaks
    hasi_id_event summary_replay_naks = 5;
}

// HASI Master Object Client Info
message hasi_m_object_slave_info {
    // SlaveId
    uint32 slave_id = 1;
    // IdEvents
    hasi_m_id_events id_events = 2;
}

// HASI Master Object Context
message hasi_m_object_ctx {
    // ObjectSyncID
    uint64 object_sync_id = 1;
    // ObjectType
    uint32 object_type = 2;
    // Queue
    uint32 queue = 3;
    // CreateID
    uint64 create_id = 4;
    // CreateTime
    uint32 create_time = 5;
    // UpdateTime
    uint32 update_time = 6;
    // DeleteTime
    uint32 delete_time = 7;
    // DeleteContextLength
    uint32 delete_ctx_lenght = 8;
    // SlaveInformation
    repeated hasi_m_object_slave_info slave_information = 9;
    // HasHistory
    bool has_history = 10;
    // PreActiveHistory
    hasi_s_obj_id_events pre_active_history = 11;
}

message te_serv_p2mp_auto_tun {
    // Client Context
    uint32 context = 1;
    // Client
    string client = 2;
    // Tunnel Source Address
    string source = 3;
    // Tunnel Attribute Set Name
    string attribute_set_name = 4;
    // Tunnel Attribute Set Resolved
    bool attribute_set_resloved = 5;
    // Forwarding info to be sent to LMRIB
    repeated uint32 egress_information = 6;
    // EgressInfoState
    uint32 state = 7;
    // EgressInfoResult
    uint32 result = 8;
    // Time at which it was last updated
    uint64 updated = 9;
    // Needs to be replayed
    bool needs_replay = 10;
}

message te_serv_p2p_auto_tun {
    // Client Context
    uint32 context = 1;
    // Protocol Type
    string protocol_tyoe = 2;
    // Client Instance Name
    string client_instance_name = 3;
    // Tunnel Destination Address
    string destination = 4;
    // Explicit Path
    string explicit_path = 5;
    // Tunnel Attribute Set Name
    string attribute_set_name = 6;
    // Tunnel Attribute Set Resolved
    bool attribute_set_resolved = 7;
    // Time at which it was last updated
    uint64 updated = 8;
    // Needs to be replayed
    bool needs_replay = 9;
    // IPv6 Caps Requested
    bool ipv6_caps_requested = 10;
    // IPv6 Caps Enabled
    bool ipv6_caps_enabled = 11;
    // Backup Tunnel
    bool backup_tunnel = 12;
    // Next hop
    string next_hop = 13;
    // Outgoing Interface Name
    string outgoing_interface = 14;
    // Label stack
    repeated uint32 label_stack = 15;
}

// Egress info
message te_serv_p2mp_einfo {
    // Client
    string client = 1;
    // State
    uint32 state = 2;
    // Result
    uint32 result = 3;
    // Forwarding info to be sent to LMRIB
    repeated uint32 egress_information = 4;
    // Time at which it was last updated
    uint64 updated = 5;
    // Needs to be replayed
    bool needs_replay = 6;
}

// FSM events
message mpls_te_p2mp_fsm_event_counts {
    // FSM event counts
    repeated uint32 counts = 1;
}

// FSM statistics
message mpls_te_p2mp_fsm_event_stat {
    // Event time
    uint32 event_time = 1;
    // Previous state
    string previous_state = 2;
    // Next state
    string next_state = 3;
    // Event ID
    string event_id = 4;
}

// FSM data
message mpls_te_p2mp_fsm_info {
    // S2L FSM state
    string s2_l_fsm_state = 1;
    // S2L Flags
    uint32 s2_l_flags = 2;
    // Deletion Cause
    string deletion_cause = 3;
    // Deletion Subcause
    string deletion_subcause = 4;
    // Number of injected events
    uint32 injected_events = 5;
    // Event stats
    repeated mpls_te_p2mp_fsm_event_stat event_statistics = 6;
    // Event counts
    mpls_te_p2mp_fsm_event_counts event_counts = 7;
    // Path is yet to be received
    bool path_to_be_received = 8;
    // Resv is yet to be received
    bool reservation_to_be_received = 9;
    // Label is yet to be received
    bool label_to_be_received = 10;
    // RW yet to be received
    bool rewrite_to_be_received = 11;
    // Sync-ID is yet to be received from RSVP
    bool sync_id_from_rsvp_to_be_received = 12;
    // Sync-ID is yet to be received from MASTER-TE
    bool sync_id_from_master_to_be_received = 13;
    // The outgoing interface for this S2L has gone down
    bool frr_active_pending = 14;
    // The S2L properties that are synced do not match the config
    bool config_consistent = 15;
    // TRUE if there is no vifi for this HEAD S2L
    bool missing_vif = 16;
    // TRUE if the signaled name in the S2L is different than the vif
    bool signame_diff = 17;
    // TRUE if the FRR property in the S2L is different than the vif
    bool frr_diff = 18;
    // TRUE if the FRR Node Protection property in the S2L is different than the vif
    bool frr_np_diff = 19;
    // TRUE if the FRR Bandwidth Protection property in the S2L is different than the vif
    bool frr_bwp_diff = 20;
    // TRUE if the Record Route property in the S2L is different than the vif
    bool record_route_diff = 21;
    // TRUE if the soft preemption property in the S2L is different than the vif
    bool soft_preemption_diff = 22;
}

message te_serv_p2mp_einfos {
    // P2MP Services Info Array
    repeated te_serv_p2mp_einfo service_infos = 1;
}

// Endpoint Services Information
message te_service_info {
    string service_type = 1;
    // VIF Egress-Info
    te_serv_p2mp_einfos vif_egress_info = 2;
    // S2L Egress-Info
    te_serv_p2mp_einfos s2_l_egress_info = 3;
    // VIF Auto-Tunnel Info
    te_serv_p2mp_auto_tun vif_auto_tunnel_info = 4;
    // VIF P2P Auto-Tunnel Info
    te_serv_p2p_auto_tun vif_auto_tunnel_p2_p_info = 5;
}

// ODU flex info for CBR framing type
message te_odu_flex_cbr_info {
    // Bit rate in kbit/s
    uint32 bit_rate = 1;
    // Tolerance
    uint32 tolerance = 2;
}

// ODU flex info for resizable GFP-F framing type
message te_odu_flex_gfp_f_res_info {
    // Bit rate in kbit/s
    uint32 bit_rate = 1;
}

// ODU flex info for non-resizable GFP-F framing type
message te_odu_flex_gfp_f_non_res_info {
    // Bit rate in kbit/s
    uint32 bit_rate = 1;
}

// ODU bandwidth union
message te_odu_v3_bw {
    string odu_level = 1;
    // Odu flex CBR info
    te_odu_flex_cbr_info odu_flex_cbr = 2;
    // Odu flex GFP-F resizable info
    te_odu_flex_gfp_f_res_info odu_flex_gfp_f_res = 3;
    // Odu flex GFP-F non-resizable info
    te_odu_flex_gfp_f_non_res_info odu_flex_gfp_f_non_res = 4;
}

// TE Logging Attributes
message mpls_te_logging_attributes {
    // LSP State logging: TRUE - enabled, FALSE - disabled
    bool lsp_state = 1;
    // S2L State logging: TRUE - enabled, FALSE - disabled
    bool s2_l_state = 2;
    // LSP re-route logging: TRUE - enabled, FALSE - disabled
    bool lsp_re_route = 3;
    // LSP re-optimization logging: TRUE - enabled, FALSE - disabled
    bool lsp_re_opt = 4;
    // LSP insufficient bandwidth logging: TRUE - enabled, FALSE - disabled
    bool lsp_insufficient_bw = 5;
    // LSP bandwidth change logging: TRUE - enabled, FALSE - disabled
    bool lsp_bandwidth_change = 6;
    // LSP pcalc failure logging: TRUE - enabled, FALSE - disabled
    bool lsp_pcalc_failure_logging_enabled = 7;
    // All logging option: TRUE - enabled, FALSE - disabled
    bool all_logging_enabled = 8;
}

// TE Auto-mesh Attribute Set
message mpls_te_attribute_set_auto_mesh {
    // Bandwidth value in kbps
    uint32 configured_bandwidth = 1;
    // DSTE Class
    uint32 dste_class_type = 2;
    // Is bandwidth configured
    bool is_bandwidth_configured = 3;
    // Setup priority
    uint32 setup_priority = 4;
    // Hold priority
    uint32 hold_priority = 5;
    // Is priority configured
    bool is_priority_configured = 6;
    // deprecated
    uint32 policy_class = 7;
    // PBTS policy classes
    repeated uint32 policy_classes = 8;
    // Is policy class configured
    bool is_policyclass_configured = 9;
    // Forward class
    uint32 forward_class = 10;
    // Affinity
    mpls_te_tunnels_affinity_info affinity = 11;
    // Is affinity configured
    bool is_affinity_configured = 12;
    // Fast reroute
    bool fast_reroute = 13;
    // FRR Node protection
    bool frr_node_protection = 14;
    // FRR bandwidth protection
    bool frr_bandwidth_protection = 15;
    // Record route
    bool record_route = 16;
    // Auto bandwidth collect only
    bool auto_bandwidth_collect = 17;
    // Announce auto route to IGP
    bool auto_route_announce = 18;
    // Soft preemption is configured
    bool soft_preemption_configured = 19;
    // Logging attributes
    mpls_te_logging_attributes logging = 20;
    // IM bandwidth
    uint32 bandwidth = 21;
    // Load-Share
    uint32 load_share = 22;
    // Is Interface BW configured
    bool is_interface_bw_configured = 23;
    // Meshgroup ID
    repeated uint32 mesh_group_id = 24;
    // Tunnel ID
    repeated uint32 tunnel_id = 25;
}

// TE Protected Interface Name String
message mpls_te_protected_if_name_str {
    // Protected Interface Name
    string protected_interface = 1;
}

// Attribute set signalled name
message mpls_te_attribute_set_sig_name {
    // Signalled name
    string name = 1;
    // Source address or name
    string source_type = 2;
    // Protected interface address or name
    string protected_interface_type = 3;
    // MP address appended
    bool is_mp_addresses = 4;
}

// TE Auto-backup Attribute Set
message mpls_te_attribute_set_auto_backup {
    // Is signalled name configured
    bool is_signalled_name_configured = 1;
    // Signalled name
    mpls_te_attribute_set_sig_name signalled_name = 2;
    // Setup priority
    uint32 setup_priority = 3;
    // Hold priority
    uint32 hold_priority = 4;
    // Is priority configured
    bool is_priority_configured = 5;
    // deprecated
    uint32 policy_class = 6;
    // PBTS policy classes
    repeated uint32 policy_classes = 7;
    // Is policy class configured
    bool is_policyclass_configured = 8;
    // Affinity
    mpls_te_tunnels_affinity_info affinity = 9;
    // Is affinity configured
    bool is_affinity_configured = 10;
    // Record route
    bool record_route = 11;
    // Logging attributes
    mpls_te_logging_attributes logging = 12;
    // Array of Protected Interface Names
    repeated mpls_te_protected_if_name_str protected_interfaces = 13;
    // Tunnel ID
    repeated uint32 tunnel_id = 14;
}

// TE attribute set versioning info
message mpls_te_attribute_set_version {
    // Attribute Type
    string attribute_type = 1;
    // Generation
    uint32 generation = 2;
    // Is default
    bool is_default = 3;
}

// TE segment routing path list
message mpls_te_attribute_set_bfd_rev_path {
    // BFD reverse path type
    string path_type = 1;
    // BFD reverse path binding label
    uint32 binding_label = 2;
}

// TE Path Option Attribute Set
message mpls_te_attribute_set_path_option {
    // Bandwidth value in kbps
    uint32 configured_bandwidth = 1;
    // Cost limit on the tunnel path
    uint32 cost_limit = 2;
    // DSTE Class
    uint32 dste_class_type = 3;
    // The bandwidth type
    string bandwidth_type = 4;
    // Is bandwidth configured
    bool is_bandwidth_configured = 5;
    // Is Cost Limit configured
    bool is_cost_limit_configured = 6;
    // Affinity
    mpls_te_tunnels_affinity_info affinity = 7;
    // Is affinity configured
    bool is_affinity_configured = 8;
    // Tunnel ID
    repeated uint32 tunnel_id = 9;
    // Generation
    uint32 generation = 10;
    // Version Info
    repeated mpls_te_attribute_set_version version_info = 11;
    // Path invalidation interval on the tunnel path
    uint32 path_invalidation_timeout = 12;
    // Path invalidation action
    uint32 path_invalidation_action = 13;
    // Is path invalidation timeout configured
    bool is_path_invalidation_timeout_configured = 14;
    // Is path invalidation action configured
    bool is_path_invalidation_action_configured = 15;
    // Exclude list name
    string exclude_list_name = 16;
    // Is exclude list name configured
    bool is_exclude_list_name_configured = 17;
    // Is PCE Configured
    bool is_pce_configured = 18;
    // Is PCE Disjoint Path Source Configured
    bool is_pce_disj_source_configured = 19;
    // Is PCE Disjoint Path Type Configured
    bool is_pce_disj_type_configured = 20;
    // Is PCE Disjoint Path Group ID Configured
    bool is_pce_disj_group_id_configured = 21;
    // PCE Disjoint Path Source Address
    uint32 pcedp_source_address = 22;
    // PCE Disjoint Path Type
    string pcedp_type = 23;
    // PCE Disjoint Path Group ID
    uint32 pcedp_group_id = 24;
    // Is PCE Bidirectional Source Configured
    bool is_pceb_dj_source_configured = 25;
    // Is PCE Bidirectional Group ID Configured
    bool is_pcebd_group_id_configured = 26;
    // PCE Bidirectional Source Address
    uint32 pcebd_source_address = 27;
    // PCE Bidirectional Group ID
    uint32 pcebd_group_id = 28;
    // BFD reverse path
    mpls_te_attribute_set_bfd_rev_path bfd_reverse_path = 29;
    // Is BFD reverse path configured
    bool is_bfd_reverse_pat_configured = 30;
}

// TE XRO attribute set
message mpls_te_attribute_set_xro {
    // The XRO specified by this attribute-set
    te_xro xro = 1;
}

// TE P2MP-TE Attribute Set
message mpls_te_attribute_set_p2mp_te {
    // Fast reroute
    bool fast_reroute = 1;
    // FRR bandwidth protection
    bool frr_bandwidth_protection = 2;
    // Setup priority
    uint32 setup_priority = 3;
    // Hold priority
    uint32 hold_priority = 4;
    // Is priority configured
    bool is_priority_configured = 5;
    // Bandwidth value in kbps
    uint32 configured_bandwidth = 6;
    // DSTE Class
    uint32 dste_class_type = 7;
    // Is bandwidth configured
    bool is_bandwidth_configured = 8;
    // Tunnel ID
    repeated uint32 tunnel_id = 9;
    // Affinity
    mpls_te_tunnels_affinity_info affinity = 10;
    // Is affinity configured
    bool is_affinity_configured = 11;
}

// TE OTN path protection attribute set
message mpls_te_attribute_set_aps_pp {
    // Sub-network Connection Mode
    string snc_mode = 1;
    // Sub-network Connection Monitoring Mode
    uint32 tcm_id = 2;
    // Protection Type
    string protection_type = 3;
    // Protection Restoration Mode
    string protection_mode = 4;
    // Wait to restore time
    uint32 wait_to_restore_time = 5;
    // Hold-off time
    uint32 hold_off_time = 6;
    // Revert Schedule
    te_revert_sch_t revert_schedule = 7;
    // Path Protection Profile Type
    string path_prot_profile_type = 8;
    // Restoration Style
    string restoration_style = 9;
}

// TE segment routing prepend entry
message mpls_te_attribute_set_sr_prepend_entry {
    // Prepend Type
    string type = 1;
    // Prepend index
    uint32 index = 2;
    // Prepend next label
    uint32 next_label = 3;
}

// TE segment routing prepend list
message mpls_te_attribute_set_sr_prepend_list {
    // List of prepend entries
    repeated mpls_te_attribute_set_sr_prepend_entry prepend_entries = 1;
}

// TE P2P-TE Attribute Set
message mpls_te_attribute_set_p2p_te {
    // Tunnel ID
    repeated uint32 tunnel_id = 1;
    // Affinity
    mpls_te_tunnels_affinity_info affinity = 2;
    // Is affinity configured
    bool is_affinity_configured = 3;
    // Path selection segment-routing type
    string path_selection_segment_routing_adjacency_protection = 4;
    // Is path selection segment routing configured
    bool is_path_selection_segment_routing_adjacency_protection_configured = 5;
    // Path invalidation timeout on the tunnel path
    uint32 path_invalidation_timeout = 6;
    // Path invalidation action
    string path_selection_invalidation_action = 7;
    // Is Path Invalidation timeout configured
    bool is_path_invalidation_timeout_configured = 8;
    // Is Path Invalidation action configured
    bool is_path_invalidation_action_configured = 9;
    // Path selection metric type
    string path_selection_metric = 10;
    // Is path selection metric configured
    bool is_path_selection_metric_configured = 11;
    // Path selection margin
    uint32 path_selection_segment_routing_margin = 12;
    // Path selection margin is_relative
    bool is_path_selection_segment_routing_margin_relative = 13;
    // Is path selection margin configured
    bool is_path_selection_segment_routing_margin_configured = 14;
    // Is path selection segment limit configured
    uint32 path_selection_segment_routing_segment_limit = 15;
    // Is path selection segment limit configured
    bool is_path_selection_segment_routing_segment_limit_configured = 16;
    // Is any of the path selection parameters configured
    bool is_path_select_configured = 17;
    // Logging attributes
    mpls_te_logging_attributes logging = 18;
    // SR prepend list
    mpls_te_attribute_set_sr_prepend_list prepend_list = 19;
    // Is SR prepend list configured
    bool is_prepend_list_configured = 20;
    // Is PCE Configured
    bool is_pce_configured = 21;
    // Is PCE Disjoint Path Source Configured
    bool is_pce_disj_source_configured = 22;
    // Is PCE Disjoint Path Type Configured
    bool is_pce_disj_type_configured = 23;
    // Is PCE Disjoint Path Group ID Configured
    bool is_pce_disj_group_id_configured = 24;
    // PCE Disjoint Path Source Address
    uint32 pcedp_source_address = 25;
    // PCE Disjoint Path Type
    string pcedp_type = 26;
    // PCE Disjoint Path Group ID
    uint32 pcedp_group_id = 27;
    // Is PCE Bidirectional Source Configured
    bool is_pceb_dj_source_configured = 28;
    // Is PCE Bidirectional Group ID Configured
    bool is_pcebd_group_id_configured = 29;
    // PCE Bidirectional Source Address
    uint32 pcebd_source_address = 30;
    // PCE Bidirectional Group ID
    uint32 pcebd_group_id = 31;
}

// TE Attribute Set Union
message mpls_te_attribute_set_union {
    string tunnel_attribute_set_type = 1;
    // MPLS TE Path Option Attribute Set
    mpls_te_attribute_set_path_option attribute_set_path_option = 2;
    // MPLS TE Auto-backup Attribute Set
    mpls_te_attribute_set_auto_backup attribute_set_autobackup = 3;
    // MPLS TE Auto-mesh Attribute Set
    mpls_te_attribute_set_auto_mesh attribute_set_automesh = 4;
    // Attribute Set XRO
    mpls_te_attribute_set_xro attribute_set_xro = 5;
    // MPLS TE P2MP-TE Attribute Set
    mpls_te_attribute_set_p2mp_te attribute_set_p2_mpte = 6;
    // Attribute Set OTN APS Path Protection
    mpls_te_attribute_set_aps_pp attribute_set_aps_pp = 7;
    // MPLS TE P2P-TE Attribute Set
    mpls_te_attribute_set_p2p_te attribute_set_p2_p_te = 8;
}

// TE Attribute Set
message mpls_te_attribute_set {
    // Attribute Set Name
    string tunnel_attribute_set_name = 1;
    // Attribute Set name CRC32 value
    uint32 tunnel_attribute_set_name_crc32 = 2;
    // Union of Attribute Sets
    mpls_te_attribute_set_union attribute_set_union = 3;
}

// GMPLS WDM fixed-grid Label
message mpls_te_mgmt_wdm_fixed_grid_label {
    // Flag to indicate whether label is set
    bool label_set = 1;
    // Grid
    string grid = 2;
    // Channel spacing
    string channel_spacing = 3;
    // Identifier
    uint32 identifier = 4;
    // Channel Number
    sint32 channel = 5;
}

// GMPLS G709 OTN fixed-size Label
message mpls_te_mgmt_g709_otn_fixed_size_label {
    // Tributary time slot
    uint32 tpn = 1;
    // Bit map length
    uint32 bit_map_length = 2;
    // Bit Map
    repeated uint32 bit_map = 3;
}

// A GMPLS label
message mpls_te_mgmt_gmpls_label {
    string label_type = 1;
    // Fixed-grid WDM label
    mpls_te_mgmt_wdm_fixed_grid_label wdm = 2;
    // Fixed-size G09 OTN label
    mpls_te_mgmt_g709_otn_fixed_size_label otn = 3;
}

// GMPLS Labels
message mpls_te_mgmt_gmpls_labels {
    // Path message (upstream) ingress label
    mpls_te_mgmt_gmpls_label path_ingress_label = 1;
    // Path message (upstream) egress label
    mpls_te_mgmt_gmpls_label path_egress_label = 2;
    // Resv message (downstream) ingress label
    mpls_te_mgmt_gmpls_label resv_ingress_label = 3;
    // Resv message (downstream) egress label
    mpls_te_mgmt_gmpls_label resv_egress_label = 4;
}

// GMPLS WDM-UNI tunnel information
message mpls_te_mgmt_wdm_uni_tunnel_info {
    // Tunnel state
    string tunnel_state = 1;
    // Tunnel Role
    string tunnel_role = 2;
    // Tunnel ID
    uint32 tunnel_id = 3;
    // LSP ID
    uint32 lsp_id = 4;
    // Local optical router id
    string local_optical_router_id = 5;
    // Remote optical router id
    string remote_optical_router_id = 6;
    // Interface being controlled
    string controlled_interface = 7;
    // Source address
    string source_address = 8;
    // Destination address
    string destination_address = 9;
    // Extended tunnel-id
    string extended_tunnel_id = 10;
    // Label origin
    string label_origin = 11;
    // SRLG-discovery enabled
    bool srlg_discovery = 12;
}

// OTN tunnel's OTN technology information
message mpls_te_tunnel_otn_info {
    // Configured OTN Bandwidth for tunnel
    te_odu_v3_bw bandwidth_cfg = 1;
}

// OTN S2L's Controllers' information
message mpls_te_s2l_otn_info {
    // Incoming Controller
    string incoming_controller = 1;
    // State of Incoming Controller
    string incoming_controller_state = 2;
    // Incoming Sub Controller
    string incoming_sub_controller = 3;
    // State of Incoming Sub Controller
    string incoming_sub_controller_state = 4;
    // Outgoing Controller
    string outgoing_controller = 5;
    // State of Outgoing Controller
    string outgoing_controller_state = 6;
    // Outgoing Sub Controller
    string outgoing_sub_controller = 7;
    // State of Outgoing Sub Controller
    string outgoing_sub_controller_state = 8;
    // OTN Bandwidth for s2l
    te_odu_v3_bw bandwidth = 9;
    // Labels
    mpls_te_mgmt_gmpls_labels labels = 10;
    // Cross connect id
    uint32 cross_connect_id = 11;
    // True if subcontrollers are connected
    bool is_connected = 12;
    // XC Uptime
    uint32 uptime = 13;
    // Outgoing Controller Ifhandle
    string outgoing_controller_ifhandle = 14;
    // Outgoing Sub Controller Ifhandle
    string outgoing_sub_controller_ifhandle = 15;
    // Incoming Controller Ifhandle
    string incoming_controller_ifhandle = 16;
    // Incoming Sub Controller Ifhandle
    string incoming_sub_controller_ifhandle = 17;
    // Gpid Payload
    uint32 gpid = 18;
}

// Private Protection information signaled
message te_pvt_prot_obj_t {
    // Secondary bit
    bool s_bit = 1;
    // Protecting bit
    bool p_bit = 2;
    // Notification bit 
    bool n_bit = 3;
    // Operational bit
    bool o_bit = 4;
    // LSP Protect Type
    string protect_type = 5;
    // Is Wait-to-Restore timeout present
    bool is_wtr_present = 6;
    // Wait-to-Restore timeout
    uint32 wtr_timeout = 7;
    // Is Hold-Off timeout present
    bool is_ho_present = 8;
    // Hold-Off timeout
    uint32 ho_timeout = 9;
    // Is SNC mode present
    bool is_snc_mode_present = 10;
    // SNC mode
    string snc_mode = 11;
    // TCM_ID
    uint32 tcm_id = 12;
    // Path protection profile type
    string path_prot_profile_type = 13;
}

// APS Protection Info of S2L
message mpls_te_s2l_aps_info {
    // Protection Info
    te_pvt_prot_obj_t protection_info = 1;
}

// OTN S2l information
message mpls_te_otn_s2l_info {
    // Info Related to OTN technology in S2L
    mpls_te_s2l_otn_info otn = 1;
    // APS Info for OTN S2L
    mpls_te_s2l_aps_info aps = 2;
}

// static UNI info for both head and tail
message mpls_te_tunnel_static_uni_info {
    // Ingress Client Port
    string client_port = 1;
    // Ingress Client Port Ifhandle
    string client_if_handle = 2;
    // Client Odu Name
    string client_odu_name = 3;
    // Client Odu Interface
    string client_odu_if_handle = 4;
    // Cross connect id
    uint32 cross_connect_id = 5;
    // True if client port is connected
    bool is_connected = 6;
    // Client Port Uptime
    uint32 uptime = 7;
    // Local Termination Type
    string local_termination = 8;
    // Static_uni_type
    string static_uni_type = 9;
    // Termination Ingress Client Port
    string term_client_port = 10;
    // Termination Ingress Client Port Ifhandle
    string term_client_if_handle = 11;
}

// Circuit diversity information
message mpls_te_tunnel_vif_diversity_info {
    // Dependent Tunnel ID
    uint32 tunnel_id = 1;
}

// Transport Tunnel information
message mpls_te_transport_tunnel_info {
    // Info Related to OTN technology in S2L
    mpls_te_tunnel_otn_info otn = 1;
    // Tunnel Static UNI Info
    mpls_te_tunnel_static_uni_info static_uni = 2;
    // Tunnel EgressStatic UNI Info
    mpls_te_tunnel_egress_static_uni_info egress_static_uni = 3;
    // Homepath ero for working lsp
    repeated rsvp_mgmt_ero_subobj homepath_ero = 4;
    // Status of working homepath
    bool status_homepath_working = 5;
    // Diversity Info
    repeated mpls_te_tunnel_vif_diversity_info diversity_info = 6;
}

// APS Protection Info of tunnel
message mpls_te_tunnel_aps_info {
    // Protection Profile Information of tunnel
    mpls_te_attribute_set_aps_pp protection_profile = 1;
    // Active LSP for Incoming Data
    string active_lsp = 2;
    // Standby path diversity type
    string diversity_type = 3;
}

// Restoration info of tunnel
message mpls_te_tunnel_restoration_info {
    // Revertive or non-revertive
    string revert_option = 1;
    // LSP from which restoration LSP is DIVERSED
    string diverse_lsp = 2;
    // Restoration path diversity type
    string diversity_type = 3;
}

// Bidirectional Tunnel Information
message mpls_te_tunnel_otn_bidir_info {
    // APS Protection Info
    mpls_te_tunnel_aps_info aps = 1;
    // Restoration Info
    mpls_te_tunnel_restoration_info restoration = 2;
}

// TE Segment-Routing S2L path hop
message te_s2l_sr_path_hop {
    // Type of the SID
    string sid_type = 1;
    // Node has IP addresses specified
    bool has_ip_addresses = 2;
    // Local IP address of adjacency or Node ID
    string local_addr = 3;
    // Remote IP address of adjacency
    string remote_addr = 4;
    // Hop has MPLS label specified
    bool has_mpls_label = 5;
    // The MPLS label value
    uint32 mpls_label_value = 6;
    // Hop has EL specified
    bool has_entropy_label = 7;
}

// Path protection log entry
message te_pp_sw_log_entry_bag {
    // The index number of the path protection switch over event
    uint32 path_protection_switchover_event_index = 1;
    // The ID of the tunnel that experienced switchover
    uint32 path_protection_tunnel_id = 2;
    // The LSP ID from which the traffic was switched over
    uint32 from_lsp_id = 3;
    // The LSP ID to which the traffic was switched over
    uint32 to_lsp_id = 4;
    // The date when the error that caused the switchover was detected. This date is the number of seconds since Jan 1st 1970
    uint32 date_of_error_detection = 5;
    // The milliseconds offset of the date when the error that caused  the switchover was detected.
    uint32 date_of_error_detection_millisec = 6;
    // The time in milliseconds between the detection of the error and switching the traffic
    uint32 switchover_duration_millisec = 7;
    // The reason that caused the path protection switchover
    string path_protection_switchover_reason = 8;
}

// Path computation error information
message mpls_te_p2mp_pcalc_error {
    // Error message (for display purposes only)
    string error_message = 1;
    // LSP Mode
    string lsp_mode = 2;
    // Time in seconds seconds (since Jan. 1, 1970) when the error message is logged
    uint32 log_time = 3;
}

// P2MP signalling error
message mpls_te_p2mp_sig_error {
    // Source address of the error generating node
    uint32 error_node = 1;
    // Path Error code
    uint32 error = 2;
    // Path Error subcode
    uint32 sub_code = 3;
    string lsp_mode = 4;
    // Time in seconds when the error message is logged
    uint32 log_time = 5;
    // LSP-id for which the error was received
    uint32 signalling_lsp_id = 6;
    // Error message (for display purposes only)
    string error_message = 7;
    // Indicates if error is on the reverse LSP
    bool reverse_lsp = 8;
}

// P2MP path-option
message mpls_te_p2mp_path_option {
    // The path option index is valid
    bool option_index_is_valid = 1;
    // Path option index
    uint32 option_index = 2;
    // Path option name
    string path_option_name = 3;
    // Path option type
    string path_option_type = 4;
    // Explicit Path Name, this is the key to table ExplicitPaths.NameTable
    string explicit_path_name = 5;
    // Explicit Path ID, this is the key to table ExplicitPaths.IdentifierTable
    uint32 explicit_path_id = 6;
    // Holddown Duration (seconds)
    uint32 holddown_duration = 7;
    // PCE server address
    string pce_address = 8;
    // The path-option area constraint
    string path_option_area_id = 9;
    // TRUE if explicit path is strict
    bool is_strict_explicit_path = 10;
    // TRUE if path is helddown
    bool is_helddown = 11;
    // TRUE if the path is locked down
    bool is_lockdown = 12;
    // TRUE if the path is verbatim
    bool is_verbatim = 13;
    // TRUE if the path option is disabled
    bool is_disabled = 14;
    // TRUE if the path has an attribute set defined
    bool has_attribute_set = 15;
    // The path option attribute set used by this path
    mpls_te_attribute_set attribute_set = 16;
    // TRUE if the path has found the defined attribute set
    bool attribute_set_found = 17;
    // Path computation information
    repeated mpls_te_p2mp_pcalc_error path_calculation_error = 18;
    // Path computation remerge resolve info
    repeated mpls_te_p2mp_pcalc_error remerge_error = 19;
    // Signalling information
    repeated mpls_te_p2mp_sig_error signalling_error = 20;
    // TRUE if the path has an XRO attribute set configured
    bool has_xro_attribute_set = 21;
    // TRUE if the path's XRO attribute set is known
    bool xro_attribute_set_found = 22;
    // The XRO attribute set used by this path-option
    mpls_te_attribute_set xro_attribute_set = 23;
    // TRUE if the path is Segment-Routing
    bool is_segment_routing = 24;
    // Path option index for Protect path options
    uint32 protected_by_path_option_index = 25;
    // Path option index for Restore path options
    uint32 restored_from_path_option_index = 26;
}

// MPLS IEP Hop information
message mpls_te_iep_hop_bag {
    // Hop Index
    uint32 hop_index = 1;
    // IEP type
    string iep_hop_type = 2;
    // IEP Hop Address
    string iep_hop_address = 3;
}

// MPLS TE IEP
message mpls_te_iep_bag {
    // Path option ID this IEP is associated with
    uint32 path_option_id = 1;
    // IEP Hop List
    repeated mpls_te_iep_hop_bag iep_hop_list = 2;
}

// MPLS TE Tunnel AutoBandwidth Status Information
message mpls_te_tunnels_autobw_status {
    // TRUE if auto-bw is enabled for the tunnel
    bool is_auto_bandwidth_enabled = 1;
    // Time until auto-bw gets activated if activation has been delayed due to failover
    uint32 reactivation_time = 2;
}

// MPLS TE Tunnel AutoBandwidth Configuration Information
message mpls_te_tunnels_autobw_config {
    // TRUE if auto-bw collection-only is enabled
    bool is_auto_bandwidth_collect_only = 1;
    // Minimum bandwidth auto-bw can apply
    uint32 minimum_bandwidth = 2;
    // Maximum bandwidth auto-bw can apply
    uint32 maximum_bandwidth = 3;
    // Auto-bw application frequency for the tunnel (mins)
    uint32 application_frequency = 4;
    // Global auto-bw collection frequency
    uint32 collection_frequency = 5;
    // Bandwidth change threshold needed to trigger bandwidth adjustment
    uint32 adjustment_threshold_percent = 6;
    // Bandwidth change value (kbps) needed to trigger bandwidth adjustment
    uint32 adjustment_threshold_value = 7;
    // Bandwidth change threshold needed to count a collection towards overflow limit allowed
    uint32 overflow_threshold_percent = 8;
    // Bandwidth change value needed to count a collection towards overflow limit allowed
    uint32 overflow_threshold_value = 9;
    // Limit of consecutive collections exceeding threshold to trigger an immediate overflow bandwidth adjustment
    uint32 overflow_threshold_limit = 10;
    // Bandwidth change threshold needed to count a collection towards underflow limit allowed
    uint32 underflow_threshold_percent = 11;
    // Bandwidth change value needed to count a collection towards underflow limit allowed
    uint32 underflow_threshold_value = 12;
    // Limit of consecutive collections exceeding threshold to trigger an immediate underflow bandwidth adjustment
    uint32 underflow_threshold_limit = 13;
}

// MPLS TE Tunnel AutoBandwidth Operational Information
message mpls_te_tunnels_autobw_oper {
    // Last bandwidth requested by auto-bw for the tunnel
    uint32 last_bandwidth_applied = 1;
    // Bandwidth pool type
    string bandwidth_pool_type = 2;
    // Total number of bandwidth applications requested by auto-bw
    uint32 bandwidth_applications = 3;
    // The reason causing the last BW application
    string last_application_trigger = 4;
    // Amount of time introduced to delay first application so that not all tunnels may signal BW at the same time
    uint32 application_jitter = 5;
    // Time left until next auto-bw application algorithm is performed
    uint32 time_left_application = 6;
    // Number of samples collected within current application period
    uint32 samples_collected = 7;
    // Time left until next auto-bw data collection is performed
    uint32 time_left_collection = 8;
    // Highest bandwidth registered within current application period
    uint32 highest_bandwidth = 9;
    // Highest sample collected during an underflow sequence
    uint32 underflow_highest_bandwidth = 10;
    // counter for current consecutive collections exceeding threshold
    uint32 threshold_overflows = 11;
    // tunnel counter for number of bandwidth applications due to overflow
    uint32 overflow_early_bw_applications = 12;
    // counter for current consecutive collections exceeding threshold
    uint32 threshold_underflows = 13;
    // tunnel counter for number of bandwidth applications due to underflow
    uint32 underflow_early_bw_applications = 14;
    // Collect-only Requested Bandwidth for the tunnel
    uint32 collect_only_requested_bandwidth = 15;
    // Current application reject reason
    string application_reject_reason = 16;
}

// Last re-opt failure reason/information if applicable
message mpls_te_tunnels_tunnel_last_reopt_fail_info {
    // Reason (if any) for the last re-opt attempt failure
    string re_opt_last_fail_reason = 1;
    // First tunnel destination (if any) in re-opt LSP that failed to come up
    string re_opt_failed_destination = 2;
    // Time stamp of the last re-opt failure. (seconds since Jan. 1, 1970)
    uint32 re_opt_failed_timestamp = 3;
}

// History information for currently connected setup
message mpls_te_tunnels_history_current_connected {
    // Time in seconds since the current LSP was up
    uint32 current_lsp_uptime = 1;
    // Time in seconds since the tunnel was up
    uint32 current_uptime = 2;
}

// History information for current setup
message mpls_te_tunnels_history_current {
    // Uptimes for connected setup
    mpls_te_tunnels_history_current_connected connected_uptimes = 1;
    // Time in seconds until the next attempt to connect this setup
    uint32 current_setup_timer = 2;
    // The reason why this setup is selected. For display purposes only.
    string selection_reason = 3;
    // The last error for the current setup
    string current_setup_last_error = 4;
}

// History information for reoptimized setup
message mpls_te_tunnels_history_reopt {
    // Time in seconds since the reopt setup came up
    uint32 reoptimized_setup_uptime = 1;
    // Time in seconds until the next attempt to connect the reopt setup
    uint32 reoptimized_setup_timer = 2;
    // The last error for the reopt setup
    string reoptimized_setup_last_error = 3;
}

// History information for protecting setup
message mpls_te_tunnels_history_path_protect {
    // Time in seconds since the protecting setup came up
    uint32 protecting_setup_uptime = 1;
    // Time in seconds until the next attempt to connect the protecting setup
    uint32 protecting_setup_timer = 2;
    // The last error for the protecting setup (for display purposes only)
    string protecting_setup_last_error = 3;
}

// History information for previous current setup
message mpls_te_tunnels_history_previous {
    // The previous setup path option
    string previous_path_option = 1;
    // The previous setup's instance
    uint32 previous_tunnel_instance = 2;
    // Reason for the previous setup's failure
    string previous_fail_reason = 3;
    // The last error for the previous setup
    string previous_setup_last_error = 4;
}

// History information for previous protecting GMPLS current setup
message mpls_te_tunnels_history_previous_protect {
    // The previous protect setup path option
    string previous_protect_path_option = 1;
    // The previous protect setup's instance
    uint32 previous_protect_tunnel_instance = 2;
    // Reason for the previous protect setup's failure
    string previous_protect_fail_reason = 3;
    // The last error for the previous setup
    string previous_protect_setup_last_error = 4;
}

// History information for additional GMPLS setup
message mpls_te_tunnels_history_other_setup {
    // Path option index for the additional setup
    uint32 path_option_index = 1;
    // The last error for the additional setup
    string other_setup_error = 2;
}

// History information for standby setup
message mpls_te_tunnels_history_standby_setup {
    // Time in seconds since the standby LSP was up
    uint32 standby_lsp_uptime = 1;
    // Time in seconds until the next attempt to connect this setup
    uint32 standby_setup_timer = 2;
}

// MPLS TE Tunnel History Information
message mpls_te_tunnels_history_bag {
    // Current setup data
    mpls_te_tunnels_history_current current_setup = 1;
    // Reoptimized setup data
    mpls_te_tunnels_history_reopt reopt_setup = 2;
    // GMPLS protecting setup data
    mpls_te_tunnels_history_path_protect gmpls_path_protect_setup = 3;
    // Previous setup data
    mpls_te_tunnels_history_previous previous_setup = 4;
    // Previous GMPLS protecting setup data
    mpls_te_tunnels_history_previous_protect previous_gmpls_path_protect_setup = 5;
    // GMPLS additional setup data
    mpls_te_tunnels_history_other_setup gmpls_other_setup = 6;
    // GMPLS additional protecting setup data
    mpls_te_tunnels_history_other_setup gmpls_other_protect_setup = 7;
    // Standby setup data
    mpls_te_tunnels_history_standby_setup standby_setup = 8;
    // Standby Reopt setup data
    mpls_te_tunnels_history_reopt standby_reopt_setup = 9;
    // Last re-opt attempt failure information
    mpls_te_tunnels_tunnel_last_reopt_fail_info last_re_opt_fail = 10;
    // Last standby re-opt attempt failure information
    mpls_te_tunnels_tunnel_last_reopt_fail_info last_stdby_re_opt_fail = 11;
}

// MPLS TE Tunnel Reverse ERO Error Information
message mpls_te_tunnels_reverse_ero_error_bag {
    // Reverse LSP ID
    uint32 reverse_lsp_id = 1;
    // Path Reject due to bw
    bool path_reject_reason_bw = 2;
    // Path Reject due to affinity
    bool path_reject_reason_affinity = 3;
    // Path Reject due to IP address
    bool path_reject_reason_ip_addr = 4;
    // Path Reject due to reverse link
    bool path_reject_reason_reverse_link = 5;
    // Path Reject due to IXCD
    bool path_reject_reason_ixcd = 6;
    // Path Reject due to holddown
    bool path_reject_reason_holddown = 7;
    // Path Reject due to exclude node
    bool path_reject_reason_exclude_node = 8;
    // Path Reject due to exclude link
    bool path_reject_reason_exclude_link = 9;
    // Path Reject due to exclude SRLG
    bool path_reject_reason_exclude_srlg = 10;
    // Path Reject due to hop limit
    bool path_reject_reason_hop_limit = 11;
    // Path Reject due to unknown node overload
    bool path_reject_reason_node_ol_unknown = 12;
    // Path Reject due to head node overload
    bool path_reject_reason_node_ol_head = 13;
    // Path Reject due to mid node overload
    bool path_reject_reason_node_ol_mid = 14;
    // Path Reject due to head node overload
    bool path_reject_reason_node_ol_tail = 15;
    // Path Reject due to reverse bw
    bool path_reject_reason_reverse_bw = 16;
    // Path Reject due to unreachable node
    bool path_reject_reason_node_unreachable = 17;
    // Path Option Index
    uint32 path_option_index = 18;
    // Path Option Type
    string path_option_type = 19;
    // Path Computation Information
    repeated mpls_te_p2mp_pcalc_error path_calculation_error = 20;
    // Reverse ERO Reject Reason
    string ero_reject_reason = 21;
}

// Counter and time information for reoptimization of interarea tunnels
message mpls_te_interarea_reopt_info {
    // Number of better path queries sent
    uint32 sent_path_queries = 1;
    // Time since the last better path query was sent (seconds)
    uint32 time_since_last_query_sent = 2;
    // Number of received Preferred Path Exists Error
    uint32 received_preferred_path_errors = 3;
    // Time since last Preferred Path Exists error received (seconds)
    uint32 time_since_last_preferred_path_error = 4;
    // Number of received Preferred Tree Exists Error
    uint32 received_preferred_tree_errors = 5;
    // Time since last Preferred Tree Exists error received (seconds)
    uint32 time_since_last_preferred_tree_error = 6;
    // Address of the preferred path error generating node
    string preferred_path_error_node = 7;
    // Address of the preferred tree error generating node
    string preferred_tree_error_node = 8;
}

// TE G709 OTN TSpec
message te_mgmt_g709_otn_tspec {
    // Signal Type
    uint32 signal_type = 1;
    // NMC or Tolerance
    uint32 nmc_or_tolerance = 2;
    // Number of Virtual Components
    uint32 nvc = 3;
    // Multiplier
    uint32 multiplier = 4;
    // Bit Rate in kbps
    uint32 bit_rate = 5;
}

// Union of different TE generic TSpec types
message te_mgmt_generic_tspec {
    string t_spec_type = 1;
    // TE TSpec for G709 OTN
    te_mgmt_g709_otn_tspec otnt_spec = 2;
}

// TE G709 OTN FSpec
message te_mgmt_g709_otn_fspec {
    // Signal Type
    uint32 signal_type = 1;
    // NMC or Tolerance
    uint32 nmc_or_tolerance = 2;
    // Number of Virtual Components
    uint32 nvc = 3;
    // Multiplier
    uint32 multiplier = 4;
    // Bit Rate in kbps
    uint32 bit_rate = 5;
}

// Union of different TE generic FSpec types
message te_mgmt_generic_fspec {
    string f_spec_type = 1;
    // TE FSpec for G709 OTN
    te_mgmt_g709_otn_fspec otnf_spec = 2;
}

// Bandwidth information of a flow
message bandwidth_spec_bag {
    // Average bandwidth in  kbps
    uint64 average_rate = 1;
    // Maximum burst of data in bytes
    uint64 maximum_burst = 2;
    // Peak rate in  kbps
    uint64 peak_rate = 3;
}

// TE LSP convergence related information
message te_lsp_convergence_info {
    // LSP RSVP Path-in timestamp (clocktime in nsecs)
    uint64 path_in = 1;
    // LSP RSVP Path-in timestamp (clocktime in nsecs)
    uint64 path_out = 2;
    // LSP RSVP Resv-in timestamp (clocktime in nsecs)
    uint64 resv_in = 3;
    // LSP RSVP Resv-out timestamp (clocktime in nsecs)
    uint64 resv_out = 4;
    // LSP Label rewrite timestamp (clocktime in nsecs)
    uint64 label_rewrite = 5;
    // Tunnel rewrite timestamp (clocktime in nsecs)
    uint64 tunnel_rewrite = 6;
}

// Headend Soft Preemption Counters
message mpls_te_soft_preemption_head_counters {
    // The number of soft preemption events
    uint32 soft_preemption_events = 1;
    // The number of soft preempted LSPs that were torn down by the ingress router after the reopt LSP was successfully setup.
    uint32 reopt_completed_ls_ps = 2;
    // The number of soft preempted LSPs that were torn down by the headend or any remote node before the reoptimization is done.
    uint32 torn_down_ls_ps = 3;
    // The number of soft preempted LSPs that were switched over to a standby LSP.
    uint32 path_protection_switchover_ls_ps = 4;
    // The number of soft preempted LSPs that were fast rerouted at the headend or any remote node before the reoptimization is done.
    uint32 frr_triggered_ls_ps = 5;
    // The minimum time in seconds that an LSP was in preemption pending state
    uint32 time_in_preemption_pending_min = 6;
    // The maximum time in seconds that an LSP was in preemption pending state
    uint32 time_in_preemption_pending_max = 7;
    // The average time in seconds that an LSP was in preemption pending state
    uint32 time_in_preemption_pending_avg = 8;
}

// Information for a soft preemption path error
message mpls_te_soft_preemption_path_error {
    // The POSIX timestamp when the soft preemption error is received
    uint32 timestamp = 1;
    // The address of the link where the preemption happened
    string preempting_link_address = 2;
}

// Headend Soft Preemption Tunnel Info
message mpls_te_soft_preemption_tunnel_info {
    // The preemption state
    string status = 1;
    // The array of soft preemption path errors info received for the LSP that is being soft preempted
    repeated mpls_te_soft_preemption_path_error soft_preemption_path_errors = 2;
    // The number of seconds that were spent in the preemption-pending state
    uint32 time_in_preemption_pending = 3;
    // Indicates how the soft preemption operation ended
    string preemption_pending_resolution = 4;
    // The soft preemption counters for this tunnel head
    mpls_te_soft_preemption_head_counters soft_preemption_counters = 5;
}

// Midpoint Soft Preemption LSP Info
message mpls_te_soft_preemption_lsp_info {
    // The current state of the soft preemption operation
    string status = 1;
    // The POSIX timestamp when the soft preemption occurred
    uint32 soft_preemption_timestamp = 2;
    // Name of the link where the soft preemption occurred
    string soft_preemption_link = 3;
    // The address of the link where the preemption happened
    string preempting_link_address = 4;
    // The number of seconds until hard preemption is triggered
    uint32 time_to_hard_preemption = 5;
    // FRR-rewrite during soft preemption
    bool fr_rrewrite = 6;
    // The tunnel name of the backup
    string fr_rrewrite_tunnel_name = 7;
}

// Hop information
message tunnel_hop_info {
    // Hop address
    string hop_address = 1;
    // Deprecated
    uint32 hop_affinity = 2;
    // Hop affinity
    repeated uint32 hop_extended_affinity = 3;
}

// TE tunnel convergence related information
message te_vif_convergence_info {
    // TE convergence in progress
    bool is_convergence_in_progress = 1;
    // FRR trigger time
    uint64 frr_trigger_time = 2;
    // Path computation completion timestamp (clocktime in nsecs)
    uint64 pcalc_complete_time = 3;
    // TE convergence completion time
    uint64 convergence_complete_time = 4;
    // TE LSP convergence related information
    te_lsp_convergence_info convergence_lsp = 5;
}

// BFD configuration info for a tunnel
message mpls_te_tunnel_bfd_config_info {
    // Deprecated
    bool bfd_fast_detecting_enabled = 1;
    // BFD Type
    string bfd_type = 2;
    // Hello interval in milliseconds
    uint32 min_interval = 3;
    // Is default hello interval
    bool min_interval_default = 4;
    // Multiplier
    uint32 multiplier = 5;
    // Is default multiplier
    bool multiplier_default = 6;
    // Bring Up Timeout in second
    uint32 bring_up_timeout = 7;
    // Is default bring up timeout
    bool bring_up_timeout_default = 8;
    // Dampening initial wait time in milliseconds
    uint32 dampening_initial_wait = 9;
    // Is default dampening inital wait time
    bool dampening_initial_wait_default = 10;
    // Dampening max wait time in milliseconds
    uint32 dampening_max_wait = 11;
    // Is default dampening max wait time
    bool dampening_max_wait_default = 12;
    // Dampening secondary wait time in milliseconds
    uint32 dampening_secondary_wait = 13;
    // Is default dampening secondary wait time
    bool dampening_secondary_wait_default = 14;
    // Periodic LSP Ping disabled
    bool periodic_lsp_ping_disabled = 15;
    // Periodic LSP Ping interval in seconds
    uint32 periodic_lsp_ping_interval = 16;
    // Is default LSP Ping interval
    bool periodic_lsp_ping_interval_default = 17;
    // BFD Session Down Action
    string bfd_session_down_action = 18;
    // BFD Session Down Reopt Timeout
    uint32 bfd_session_down_reopt_timeout = 19;
    // BFD Encap Mode
    string bfd_encap_mode = 20;
    // SBFD Target ID
    string sbfd_target_id = 21;
}

// Bidirectional configuration info for a tunnel
message mpls_te_tunnel_bidir_config_info {
    // Association Type (draft-ietf-ccamp-mpls-tp-rsvpte-ext-associated-lsp)
    uint32 association_type = 1;
    // The association ID
    uint32 association_id = 2;
    // The association source
    string association_source = 3;
    // The association global ID
    uint32 association_global_id = 4;
    // Is the association co-routed
    bool association_corouted = 5;
}

// A P2MP destination
message mpls_te_p2mp_dest {
    // Destination address
    string destination_address = 1;
    // Deprecated; replaced by PathOption
    repeated mpls_te_p2mp_path_option path_options = 2;
    // Destination's list of path options
    repeated mpls_te_p2mp_path_option path_option = 3;
    // The state of the destination
    string destination_state = 4;
    // Index of active path option
    uint32 active_path_option_index = 5;
    // Path options are exhausted
    bool path_option_exhausted = 6;
    // Time in seconds since the destination was up
    uint32 uptime = 7;
    // Last path change time
    uint32 path_change_time = 8;
    // Unused
    uint32 total_uptime = 9;
    // Dest state may not be up but S2L may exist
    bool s2_l_exist = 10;
    // Destination deletion cause
    string destination_deletion_cause = 11;
    // Destination deletion subcause
    string destination_deletion_sub_cause = 12;
    // Destination deletion timestamp in seconds
    uint32 destination_deletion_timestamp = 13;
    // Indicates whether this destination is in different area
    bool is_inter_area = 14;
    // The timing and count information of interarea reoptimization.
    mpls_te_interarea_reopt_info inter_area_reoptimization = 15;
}

// An Autoroute destination
message mpls_te_autoroute_destination_bag {
    // Destination address
    string destination_address = 1;
    // Prefix length
    uint32 prefix_length = 2;
}

// TE BFD Session Info
message mpls_te_bfd_session_info {
    // BFD session state
    string state = 1;
    // Time in seconds since the last session state change
    uint32 state_change_time = 2;
}

// TE Tunnel BFD Session Deletion History
message mpls_te_bfd_deletion_history {
    // LSP ID of the BFD session get deleted
    uint32 lsp_id = 1;
    // Time stamp of the BFD session get deleted
    uint32 deletion_time = 2;
    // Reason for the BFD session get deleted
    string deletion_reason = 3;
    // Diagnostic Code for the BFD session get deleted
    uint32 deletion_diagnostic_code = 4;
}

// TE Head-end BFD information
message mpls_te_head_bfd_info {
    // Time in seconds since the BFD session created
    uint32 creation_time = 1;
    // BFD Session Info
    mpls_te_bfd_session_info session_info = 2;
    // BFD Session Deletion History
    mpls_te_bfd_deletion_history deletion_history = 3;
    // LSP BFD type
    string lspbfd_type = 4;
    // sBFD session is redundant
    bool is_redundant = 5;
    // BFD reverse path labels
    repeated uint32 bfd_reverse_path_labels = 6;
    // The BFD reverse path is stale compared to configuration
    bool bfd_reverse_path_stale = 7;
}

// TE Tail-end BFD information
message mpls_te_tail_bfd_info {
    // BFD Session Info
    mpls_te_bfd_session_info session_info = 1;
    // BFD session failure diagnostic code
    uint32 failure_diagnostic_code = 2;
    // BFD session failure reason
    string failure_reason = 3;
    // BFD Local Discriminator
    uint32 local_discriminator = 4;
    // BFD Remote Discrminator
    uint32 remote_discriminator = 5;
    // Hello interval in mini second
    uint32 min_interval = 6;
    // Is default hello interval
    bool min_interval_default = 7;
    // Multiplier
    uint32 multiplier = 8;
    // Is default multiplier
    bool multiplier_default = 9;
}

// TE Association Object
message mpls_te_s2l_association_object {
    // S2L Association Type (draft-ietf-ccamp-mpls-tp-rsvpte-ext-associated-lsp)
    uint32 s2_l_association_type = 1;
    // S2L Association Tie Role
    string s2_l_association_tie_role = 2;
    // S2L Association ID
    uint32 s2_l_association_id = 3;
    // S2L Association Source
    string s2_l_association_source = 4;
    // S2L Global Source
    uint32 s2_l_global_source = 5;
    // S2L Extended ID Array
    repeated uint32 s2_l_extended_id = 6;
}

// TE Protection Object
message mpls_te_s2l_protection_object {
    //  S2L Protection Secondary Bit
    bool s2_l_secondary = 1;
    //  S2L Protection Protecting Bit
    bool s2_l_protecting = 2;
    //  S2L Protection Notification Bit
    bool s2_l_notification = 3;
    //  S2L Protection Operational Bit
    bool s2_l_operational = 4;
    // Indicates Enhanced Protection Scheme
    bool enhanced = 5;
    // Dedicated 1+1 Protection
    bool ded1_plus1 = 6;
    // Dedicated 1:1 Protection
    bool ded1_to1 = 7;
    // Shared Link Layer Protection
    bool shared = 8;
    // LSP should not use any Link Layer Protection
    bool link_unprotected = 9;
    // LSP should use Links that are protecting other (primary) traffic
    bool extra_traffic = 10;
    // Any
    bool any = 11;
    // Full Rerouting
    bool rerouting = 12;
    // Rerouting Without Extra-Traffic
    bool rerouting_no_et = 13;
    // 1:N Protection with Extra-Traffic
    bool one_to_n_protection_et = 14;
    // 1+1 Unidirectional Protection
    bool one_plus_one_uni = 15;
    // 1+1 Bidirectional Protection
    bool one_plus_one_bi = 16;
    // LSP Flags Unprotected
    bool lsp_unprotected = 17;
}

// Information about flex LSP lockout info for the link
message flex_lockout_t {
    // True if s2l is locked out
    bool is_lockout = 1;
    // Flex LSP Lockout Origination Source
    string origination = 2;
    // The timestamp when the lockout is set
    uint32 lockout_timestamp = 3;
}

// TE Per-S2L FlexLSP Information
message mpls_te_s2l_flex_info {
    // FlexLSP Entry Exists
    bool entry_exists = 1;
    // In Label
    uint32 in_label = 2;
    // GAL BFD Session Created
    bool bfd_created = 3;
    // GAL BFD Session Up
    bool bfd_up = 4;
    // OAM Entry Created
    bool oam_created = 5;
    // FEC for the FlexLSP Entry
    te_s2l_fec_t flex_fec = 6;
    // BFD Next Hop
    string bfd_next_hop = 7;
    // BFD Tunnel Interface Handle
    string bfd_tun_ifh = 8;
    // BFD Out Interface Handle
    string bfd_out_ifh = 9;
    // BFD Internal Label
    uint32 bfd_int_label = 10;
    // BFD Egress Label
    uint32 bfd_egress_label = 11;
    // Fault LDI Lockout
    bool fault_ldi_lockout = 12;
    // Fault LDI
    bool fault_ldi = 13;
    // Fault LKR
    bool fault_lkr = 14;
    // Fault AIS
    bool fault_ais = 15;
    // Fault Time
    uint32 fault_time = 16;
    // Flex LSP Lockout Info
    flex_lockout_t lockout = 17;
}

// SRLG-collection information
message te_s2l_srlg_collect_info {
    // SRLG-collection mechanism
    string srlg_collect_type = 1;
    // Discovered SRLGs
    repeated uint32 discovered_srl_gs = 2;
}

// Midpoint LSP Wrap Protection LSP Info
message tunnel_midpoint_lsp_wrap_info_bag {
    // LSP Wrap protection enabled
    bool lsp_wrap_protection_enable = 1;
    // LSP Wrap Merge Point Label
    uint32 lsp_wrap_protection_label = 2;
    // Reverse Egress Interface
    string reverse_egress_interface = 3;
    // Reverse LSP label
    uint32 reverse_lsp_label = 4;
    // LSP wrap protection state
    string lsp_wrap_protection_state = 5;
}

// S2l Diversity info
message mpls_te_s2l_diversity_info {
    // S2L path diversity type
    string diversity_type = 1;
}

// A P2MP S2L
message mpls_te_p2mp_s2l {
    // FEC for the S2L
    te_s2l_fec_t s2_l_fec = 1;
    // The path option used to find the path for this S2L
    mpls_te_p2mp_path_option active_path_option = 2;
    // The S2L's excluded srlg groups
    repeated mpls_srlg_info shared_risk_link_groups = 3;
    // IGP-area in which the S2L path was calculated
    string pcalc_area = 4;
    // TRUE if this LSR expanded a loose path
    bool is_expanded_ero = 5;
    // Loose path reevaluation query received at mid-point
    uint32 path_reeval_query_mid = 6;
    // Time since last reevaluation query received at mid-point
    uint32 time_since_last_query_received_mid = 7;
    // Time since last preferred path exists msg send from mid-point
    uint32 time_since_last_preferred_path_exists_send_mid = 8;
    // Time since last preferred tree exists msg send from mid-point
    uint32 time_since_last_preferred_tree_exists_send_mid = 9;
    // Indicates the protocol and area used to find Outgoing ERO
    string expanded_ero_area_id = 10;
    // The Outgoing ERO's affinity bits (colors)
    uint32 expanded_ero_affinity_bits = 11;
    // The Outgoing ERO's affinity mask (colors)
    uint32 expanded_ero_affinity_mask = 12;
    // The Outgoing ERO's selection metric
    string expanded_ero_metric_type = 13;
    // The metric value of the expanded path
    uint32 expanded_ero_metric = 14;
    // Next ABR auto discovered
    string abr_auto_discovered = 15;
    // FRR Enabled or Disabled
    bool is_frr_enabled = 16;
    // Node Protection Enabled or Disabled
    bool is_node_protected = 17;
    // BW Protection Enabled or Disabled
    bool is_bandwidth_protect = 18;
    // Path RRO Enabled or Disabled
    bool path_rro_enabled = 19;
    // Outgoing ERO for this S2L
    repeated rsvp_mgmt_ero_subobj out_ero = 20;
    // Incoming ERO for this S2L
    repeated rsvp_mgmt_ero_subobj in_ero = 21;
    // Outgoing XRO for this S2L
    te_xro out_xro = 22;
    // Incoming XRO for this S2L
    te_xro in_xro = 23;
    // Path RRO for this S2L
    repeated rsvp_mgmt_rro_subobj path_rro = 24;
    // Resv RRO for this S2L
    repeated rsvp_mgmt_rro_subobj resv_rro = 25;
    // Tunnel's Path hops with affinity
    repeated tunnel_hop_info path_affinity_array = 26;
    // The T spec info
    bandwidth_spec_bag t_spec = 27;
    // Generic TSpec
    te_mgmt_generic_tspec generic_t_spec = 28;
    // The F spec info
    bandwidth_spec_bag f_spec = 29;
    // Generic FSpec
    te_mgmt_generic_fspec generic_f_spec = 30;
    // The path's weight
    uint64 weight = 31;
    // The reverse path weight
    uint64 reverse_weight = 32;
    // Time in seconds since the tunnel was up
    uint32 uptime = 33;
    // Egress Interface
    string egress_interface = 34;
    // State of Outgoing Interface
    string egress_interface_state = 35;
    // Egress Interface in brief format
    string egress_interface_brief = 36;
    // Ingress Interface
    string ingress_interface = 37;
    // State of Incoming Interface
    string ingress_interface_state = 38;
    // Ingress Interface in brief format
    string ingress_interface_brief = 39;
    // Local label
    uint32 s2_l_local_label = 40;
    // Outgoing label
    uint32 s2_l_out_label = 41;
    // Indicates outbound FRR state
    string outbound_frr_state = 42;
    // FRR out tunnel intface
    string frr_out_tunnel_interface = 43;
    // Role of S2L
    string role = 44;
    // Signaling status
    string signalling_status = 45;
    // Local router id
    string local_router_id = 46;
    // Upstream router id
    string upstream_router_id = 47;
    // Downstream router id
    string downstream_router_id = 48;
    // Next hop address
    string next_hop_address = 49;
    // Next hop address
    te_addr_t_ next_hop_address_generic = 50;
    // Previous hop address
    string previous_hop_address = 51;
    // Previous hop address
    te_addr_t_ previous_hop_address_generic = 52;
    // Incoming interface address
    string incoming_address = 53;
    // Incoming interface address
    te_addr_t_ incoming_address_generic = 54;
    // Interface handle of the backup tunnel
    string backup_tunnel_interface = 55;
    // Hop count
    uint32 node_hop_count = 56;
    // TE LSP convergence related information
    te_lsp_convergence_info s2_l_convergence = 57;
    // The soft preemption info for this LSP.
    mpls_te_soft_preemption_lsp_info soft_preemption = 58;
    // Is Optical
    bool is_optical = 59;
    // GMPLS labels
    mpls_te_mgmt_gmpls_labels gmpls_labels = 60;
    // Otn S2L Information
    mpls_te_otn_s2l_info otn_s2_l = 61;
    // The Head-end BFD info
    mpls_te_head_bfd_info head_end_bfd_info = 62;
    // The Tail-end BFD info
    mpls_te_tail_bfd_info tail_end_bfd_info = 63;
    // SRLG-collection data
    te_s2l_srlg_collect_info srlg_collection = 64;
    // Association Object
    mpls_te_s2l_association_object association = 65;
    // Protection Object
    mpls_te_s2l_protection_object protection = 66;
    //  S2l Reverse ERO Object Present
    bool s2_l_reverse_ero_obj_present = 67;
    //  Reverse Incoming ERO for this S2L
    repeated rsvp_mgmt_ero_subobj reverse_ero_in = 68;
    // Reverse Associated Bidir LSP Present
    bool reverse_lsp_present = 69;
    // Reverse Associated Bidir LSP Connected
    bool reverse_lsp_connected = 70;
    // Reverse Associated Bidir LSP FEC
    te_lsp_fec_t reverse_lsp_fec = 71;
    // Reverse Associated Bidir LSP Name
    string reverse_lsp_name = 72;
    //  S2L Reverse TSpec Object Present
    bool s2_l_reverse_t_spec_obj_present = 73;
    // The Reverse T spec info
    bandwidth_spec_bag reverse_t_spec = 74;
    // Reverse LSP Sub Objects
    repeated uint32 s2_l_reverse_lsp_sub_objs = 75;
    // FlexLSP S2L Information
    mpls_te_s2l_flex_info flex_info = 76;
    // Segment-Routing S2L path info
    repeated te_s2l_sr_path_hop s2_l_segment_routing_path = 77;
    // Lsp Wrap  Related information
    tunnel_midpoint_lsp_wrap_info_bag lsp_wrap_info = 78;
    // Path is using Strict SPF
    bool path_using_strict_spf = 79;
    // S2L Diversity Information
    mpls_te_s2l_diversity_info diversity_info = 80;
}

// A P2MP LSP
message mpls_te_p2mp_lsp {
    // Signaled Name
    string signaled_name = 1;
    // P2MP LSP has FRR Failed
    bool is_frr_failed = 2;
    // P2MP LSP FRR active reason
    uint32 frr_active_reason = 3;
    // P2MP LSP Bandwidth
    uint32 lsp_bandwidth = 4;
    // LSP setup priority
    uint32 lsp_setup_priority = 5;
    // LSP hold priority
    uint32 lsp_hold_priority = 6;
    // The LSP bandwidth type
    string lsp_bandwidth_type = 7;
    // Do the class type and priority match a DSTE class
    bool dste_class_match = 8;
    // Matching DSTE class index
    uint32 dste_class_index = 9;
    // FEC for the LSP
    te_lsp_fec_t lsp_fec = 10;
    // The type of this LSP
    string type = 11;
    // array of S2L structures
    repeated mpls_te_p2mp_s2l s2_l_list = 12;
    // Time in seconds since the tunnel was up
    uint32 uptime = 13;
    // Number of connected S2Ls
    uint32 s2_ls_up = 14;
    // Number of proceeding S2Ls
    uint32 s2_ls_proceeding = 15;
    // Number of down S2Ls
    uint32 s2_ls_down = 16;
    // Reason for re-optimization
    string reoptimize_reason = 17;
    // Re-optimize trigger
    string reoptimize_trigger = 18;
    // Time in seconds left to take next action if any
    uint32 timer_left = 19;
    // True for passive tunnel
    bool is_passive = 20;
    // True for tunnel head
    bool is_interface = 21;
    // Time in seconds since the last path change
    uint32 last_path_change = 22;
    // Persistent forwarding statistics for number of bytes. Clear counters will not reset the counter
    uint64 persistent_bytes = 23;
    // Persistent forwarding statistics for Number of packets. Clear counters will not reset the counter
    uint64 persistent_packets = 24;
}

// P2P tunnel data
message mpls_te_p2p_info_bag {
    // Tunnels's AutoBandwidth Status information
    mpls_te_tunnels_autobw_status auto_bandwidth_status = 1;
    // Tunnels's AutoBandwidth Configuration information
    mpls_te_tunnels_autobw_config auto_bandwidth_config = 2;
    // Tunnels's AutoBandwidth Operational information
    mpls_te_tunnels_autobw_oper auto_bandwidth_oper = 3;
    // TRUE if the tunnel is bidirectional
    bool is_bidirectional = 4;
}

// Configured P2MP tunnel data
message mpls_te_p2mp_tun_cfg_bag {
    // Tunnel name
    string tunnel_name = 1;
    // Tunnel id
    uint32 tunnel_id = 2;
    // True if tunnel is a P2MP tunnel
    bool is_p2_mp = 3;
    // Signaled name
    string signaled_name = 4;
    // Configured Bandwidth
    uint32 configured_bandwidth = 5;
    // Configured Interface Bandwidth
    uint32 interface_configured_bandwidth = 6;
    // The bandwidth type
    string bandwidth_type = 7;
    // Setup priority
    uint32 setup_priority = 8;
    // Hold priority
    uint32 hold_priority = 9;
    // deprecated
    uint32 policy_class = 10;
    // PBTS policy classes
    repeated uint32 policy_classes = 11;
    // Forward class
    uint32 forward_class = 12;
    // Affinity
    mpls_te_tunnels_affinity_info affinity = 13;
    // Backup bandwidth
    uint32 backup_bandwidth = 14;
    // Backup bandwidth flags
    uint32 backup_bandwidth_flags = 15;
    // Config loadshare
    uint32 config_load_share = 16;
    // Payload type
    uint32 payload_type = 17;
    // Is in config
    bool is_in_config = 18;
    // Imposition of Explicit NULL
    bool explicit_null_imposition = 19;
    // Fast reroute enabled
    bool fast_reroute = 20;
    // TRUE if this is a backup tunnel
    bool is_backup_tunnel = 21;
    // Record route
    bool record_route = 22;
    // SRLG-discovery enabled
    bool srlg_discovery = 23;
    // Path Protection enabled
    bool path_protection_enabled = 24;
    // Hop Limit
    uint32 hop_limit = 25;
    // Cost limit on the tunnel path
    uint32 cost_limit = 26;
    // Global Cost Limit
    uint32 cost_limit_global = 27;
    // Path invalidation timeout configuration source
    uint32 path_invalidation_timeout_source = 28;
    // Path invalidation timeout interval on the tunnel path
    uint32 path_invalidation_timeout = 29;
    // Path invalidation action configuration source
    uint32 path_invalidation_action_source = 30;
    // Path invalidation action on the tunnel path
    uint32 path_invalidation_action = 31;
    // Soft preemption enabled
    bool soft_preempt = 32;
    // Bidirectional Configuration Information
    mpls_te_tunnel_bidir_config_info bidirectional_config = 33;
    // BFD Configuration Information
    mpls_te_tunnel_bfd_config_info bfd_config = 34;
    // DisableAffinityFailureReopt
    bool disable_affinity_failure_reopt = 35;
    // AffinityFailureReoptTimer
    uint32 affinity_failure_reopt_timer = 36;
    // Segment-Routing path selection type
    string segment_routing_path_selection = 37;
    // Autoroute Destinations list
    repeated mpls_te_autoroute_destination_bag autoroute_destinations = 38;
}

// MPLS TE Path Protected Switchover Information
message mpls_te_pp_info {
    // The date when the switchover was completed. This date is the number of seconds since Jan 1st 1970
    uint32 time_of_switchover_sec = 1;
    // Number of times switchover occurred
    uint32 switchover_total = 2;
    // Total times, Standby LSP ready for use
    uint32 switchover_ready = 3;
    // Number of times the standby LSP was reoptimized
    uint32 standby_reoptimized_number = 4;
    // Reason for last switchover
    uint32 switchover_reason = 5;
    // Standby path diversity type
    string diversity_type = 6;
    // Is Path Protection Configured
    bool is_path_protect_configured = 7;
    // The path option ID (level/index) of the configured explicit protecting path
    uint32 path_protection_protected_by_id = 8;
    // Flag to indicate whether tunnel has a path-option which is valid for path-protection
    bool valid_path_protection_path_option_exists = 9;
    // Is Switchover Underway
    bool is_path_protect_switch_over_underway = 10;
    // Path Protected Switchover Information
    te_pp_sw_log_entry_bag switchover = 11;
    // Remaining time until path protection reoptimization (seconds)
    uint32 reoptimization_time_remaining = 12;
}

// MPLS TE weighted SRLGs
message mpls_te_wsrlg_value_bag {
    // SRLG number
    uint32 srlg = 1;
    // SRLG name
    string srlg_name = 2;
    // Admin weight
    uint32 admin_weight = 3;
}

// Weighted SRLG info for a hop of the autobackup tunnel
message mpls_te_wsrlg_hop_bag {
    // Local IP address
    string from_address = 1;
    // Remote IP address
    string to_address = 2;
    // Sum of the admin weights for all the common SRLG values
    uint64 aggregate_admin_weight = 3;
    // Common SRLG between this hop and the protected interface
    repeated uint32 common_srlg = 4;
}

// MPLS TE weighted SRLG information for the autobackup tunnels
message mpls_te_wsrlg_info_bag {
    // SRLG values and admin weight penalties of the protected interface
    repeated mpls_te_wsrlg_value_bag protected_interface_srlg = 1;
    // Autobackup hops and the common SRLG with the protected interface
    repeated mpls_te_wsrlg_hop_bag weighted_srlg_hops = 2;
}

// MPLS TE Autobackup Information
message mpls_te_autobackup_info {
    // Number Of Protected LSPs
    uint32 protected_ls_ps = 1;
    // Number of Protected S2Ls
    uint32 protected_s2_ls = 2;
    // Number of S2L Sharing Families
    uint32 sharing_families = 3;
    // Protection type
    string ab_protection_type = 4;
    // Indicates whether SRLG Path Option is in use
    bool is_using_srlg = 5;
    // SRLG Protection Type
    string srlg_prot_type = 6;
    // Protected Interface
    string ab_protected_interface = 7;
    // Weighted SRLG info for the autobackup tunnel
    mpls_te_wsrlg_info_bag weighted_srlg_info = 8;
    // Protected Address
    string protected_address = 9;
    // AttributeSet name
    string tunnel_attribute_set_name = 10;
    // List of IEPs for the path options on this tunnel
    repeated mpls_te_iep_bag iep_list = 11;
    // Indicates if the unused removal timer is running
    bool is_unused_removal_timer_running = 12;
    // Time Remaining in Unused Removal Time in seconds
    uint32 unused_removal_remaining_time = 13;
}

// MPLS TE Automesh Information
message mpls_te_automesh_info {
    // Auto-mesh tunnel Mesh Group ID
    uint32 mesh_group_id = 1;
    // Destination List name
    string tunnel_destination_list_name = 2;
    // Flag to indicate whether unused timer running
    bool is_tunnel_unused_timer_running = 3;
    // Remaining time for unused timer in seconds
    uint32 remaining_unused_time = 4;
    // Auto-tunnel mesh group type
    string mesh_group_type = 5;
}

// MPLS TE Auto-PCC Information
message mpls_te_autopcc_info {
    // Address of owner node
    string owner_address = 1;
    // Address of creating node
    string creator_address = 2;
    // Indicates if the ID of the creating node is set
    bool has_creator_id = 3;
    // ID of creating node
    string creator_id = 4;
    // PLSP ID
    uint32 plspid = 5;
    // Symbolic name
    string symbolic_name = 6;
    // Operationally up
    bool operationally_up = 7;
}

// MPLS TE PCE Delegation Information
message mpls_te_pce_delegation_info {
    // PLSP ID
    uint32 plsp_id = 1;
    // Symbolic name
    string symbolic_name = 2;
    // Address of owner node
    string owner_address = 3;
    // Operationally up
    bool operationally_up = 4;
}

// MPLS TE Path Option Dampening Information
message mpls_te_path_option_dampening_info {
    // Path option index
    uint32 option_index = 1;
    // Hold down time in second
    uint32 hold_down_time = 2;
    // Remained time to resignal in second
    uint32 remained_time = 3;
    // Backoff count
    uint32 backoff_count = 4;
}

// MPLS TE Tunnel BFD Session Information
message mpls_te_tunnel_bfd_info {
    // Tunnel BFD session state up or down
    bool bfd_session_up = 1;
    // Time in seconds since the last session state up
    uint32 session_up_time = 2;
    // BFD session failure diagnostic code
    uint32 failure_diagnostic_code = 3;
    // BFD session failure reason
    string failure_reason = 4;
    // Minimum time in mini second for session to come up
    uint32 minimum_session_up_interval = 5;
    // Maximum time in mini second for session to come up
    uint32 maximum_session_up_interval = 6;
    // Per tunnel BFD session event counters
    mpls_te_bfd_lsp_counters event_counters = 7;
    // Path option dampening info
    repeated mpls_te_path_option_dampening_info dampening_info = 8;
}

// MPLS TE Tunnel Bidir Information
message mpls_te_tunnel_bidir_info {
    // Reverse Bandwidth value in kbps
    uint32 reverse_bandwidth = 1;
    // Reverse Bandwidth value for standby in kbps
    uint32 reverse_bandwidth_standby = 2;
    // Reverse ERO Error Current LSP
    mpls_te_tunnels_reverse_ero_error_bag reverse_ero_error_current = 3;
    // Reverse ERO Error Reopt LSP
    mpls_te_tunnels_reverse_ero_error_bag reverse_ero_error_reopt = 4;
    // Reverse ERO Error Standby LSP
    mpls_te_tunnels_reverse_ero_error_bag reverse_ero_error_standby = 5;
    // Reverse ERO Error Standby Reopt LSP
    mpls_te_tunnels_reverse_ero_error_bag reverse_ero_error_standby_reopt = 6;
}

// TE Tunnel FlexLSP Information
message mpls_te_tunnel_flex_info {
    // Fault LDI Lockout
    bool fault_ldi_lockout = 1;
    // Fault LDI
    bool fault_ldi = 2;
    // Fault LKR
    bool fault_lkr = 3;
    // Fault AIS
    bool fault_ais = 4;
    // Fault Time
    uint32 fault_time = 5;
    // Fault In Label
    uint32 fault_in_label = 6;
    // Lockout Status
    bool is_lockout = 7;
    // The timestamp when the lockout is set
    uint32 lockout_timestamp = 8;
    // The LSP ID of the locked out LSP
    uint32 lockout_lsp_id = 9;
}

