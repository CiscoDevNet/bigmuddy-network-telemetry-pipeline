// Copyright (c) 2015, Cisco Systems
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file is autogenerated
//
// The following edits are possible, without affecting the validity of the
// file:
//
//  * Fields may be renamed.
//  * Fields may be deleted.
//  * The unique numbered tag for a field may be changed, provided that
//    the ordering of tags for fields within a message is preserved.
//  * Message types may be renamed.
//  * Message types may be deleted (if all fields that reference them
//    have been deleted).
//
// All Cisco message and field extensions must be preserved (except when the
// field itself is being deleted).

syntax = "proto3";

package cisco_ios_xr_l2vpn_oper.l2vpnv2.active.bridge_domains.bridge_domain.bridge_access_pws.bridge_access_pw;

// L2VPN Bridge Pseudowire
message l2vpn_bd_pw_KEYS {
    string bridge_domain_group_name = 1;
    string bridge_domain_name = 2;
    string neighbor = 3;
    uint32 pseudowire_id = 4;
}

message l2vpn_bd_pw {
    // Pseudowire
    l2vpn_pw pseudowire = 50;
    // Static MAC addresses
    repeated l2vpn_bd_mac static_mac = 51;
    // Is Access PW
    bool is_access = 52;
    // Security Parameters
    l2vpn_bridge_port_sec_param security_parameters = 53;
}

// L2FIB statistics counters
message l2fib_stats_bag_counters {
    // packets counters
    uint64 packet_counts = 1;
    // bytes counters
    uint64 byte_counts = 2;
}

// L2FIB imposition statistics
message l2fib_stats_bag_imp {
    // imposition stats
    l2fib_stats_bag_counters imposition_stat = 1;
    // imposition mtu drop stats
    l2fib_stats_bag_counters imposition_mtu_drop = 2;
    // imposition tail drop stats
    l2fib_stats_bag_counters impostion_tail_drop = 3;
    // rx discards
    l2fib_stats_bag_counters l2fsbi_drop = 4;
    // Multicast
    l2fib_stats_bag_counters multicast = 5;
    // Broadcast
    l2fib_stats_bag_counters broadcast = 6;
    // Known Unicast
    l2fib_stats_bag_counters known_unicast = 7;
    // Unknown Unicast
    l2fib_stats_bag_counters unknown_unicast = 8;
}

// L2FIB disposition statistics
message l2fib_stats_bag_disp {
    // disposition stats
    l2fib_stats_bag_counters disposition_stat = 1;
    // disposition mtu drop stats
    l2fib_stats_bag_counters disposition_mtu_drop = 2;
    // disposition tail drop stats
    l2fib_stats_bag_counters disposition_tail_drop = 3;
    // disposition storm control multicast drop stats
    l2fib_stats_bag_counters multicast_drop = 4;
    // disposition storm control unknown unicast drop stats
    l2fib_stats_bag_counters unicast_drop = 5;
    // disposition storm control broadcast drop stats
    l2fib_stats_bag_counters broadcast_drop = 6;
    // tx discards
    l2fib_stats_bag_counters received_drops = 7;
    // Disposition dynamic ARP inspection drop statistics
    l2fib_stats_bag_counters dai_drop = 8;
    // disposition IP source guard drop statistics
    l2fib_stats_bag_counters ipsg_drop = 9;
    // Disposition Out-of-Order Drops
    l2fib_stats_bag_counters disposition_oo_o_drops = 10;
    // Disposition P2MP Stats
    l2fib_stats_bag_counters disposition_p2_mp_stats = 11;
    // Known Unicast
    l2fib_stats_bag_counters known_unicast = 12;
    // MAC Move
    l2fib_stats_bag_counters mac_move = 13;
}

// L2FIB sequence numbers
message l2fib_stats_bag_seq_num {
    // sequence number sent
    uint32 sequence_number_sent = 1;
    // sequence number expected
    uint32 sequence_number_expected = 2;
    // Bypassed inbound sequence packets
    uint64 bypassed_inbound_sequence_packet = 3;
    // Bypassed outbound sequence packets
    uint64 bypassed_out_sequence_packet = 4;
}

// L2FIB forwarding statistics
message l2fib_stats_bag_forwarding {
    // imposition stats
    l2fib_stats_bag_imp impostion_stats = 1;
    // disposition stats
    l2fib_stats_bag_disp dispostion_stats = 2;
    // sequence numbers
    l2fib_stats_bag_seq_num sequence_number = 3;
}

// L2FIB Multisegment pseudowire statistics
message l2fib_stats_bag_mspw {
    // Packets received
    uint64 received_packets = 1;
    // Bytes received
    uint64 received_bytes = 2;
}

// Interface info for Generic interface list
message item_iflist_if {
    // Interface name
    string interface_name = 1;
    // Replicate status
    string replicate_status = 2;
}

// Generic interface list info
message item_iflist_ifl {
    // Interface-list name
    string interface_list_name = 1;
    // Interface internal ID
    uint32 interface_list_id = 2;
    // Interfaces
    repeated item_iflist_if interfaces = 3;
}

// HASI ID Event
message hasi_id_event {
    // LocalID
    uint64 local_id = 1;
    // RemoteID
    uint64 remore_id = 2;
    // Time
    uint32 time = 3;
    // Count
    uint64 count = 4;
}

// HASI Slave Object ID events
message hasi_s_obj_id_events {
    // Create
    hasi_id_event create = 1;
    // Updates
    hasi_id_event updates = 2;
    // ApplicationSyncs
    hasi_id_event application_syncs = 3;
    // ApplicationNaks
    hasi_id_event application_naks = 4;
    // SummaryReplaySyncs
    hasi_id_event summary_replay_syncs = 5;
    // SummaryReplayNaks
    hasi_id_event summary_replay_naks = 6;
    // CacheNakRetries
    hasi_id_event cache_nak_retries = 7;
}

// HASI Slave Object Context
message hasi_s_object_ctx {
    // ObjectSyncID
    uint64 object_sync_id = 1;
    // ObjectType
    uint32 object_type = 2;
    // ObjectIdEvents
    hasi_s_obj_id_events object_id_events = 3;
}

// HASI Master Slave ID Events
message hasi_m_id_events {
    // ApplicationSyncs
    hasi_id_event application_syncs = 1;
    // ImplicitDeletes
    hasi_id_event implicit_deletes = 2;
    // ApplicationNaks
    hasi_id_event application_naks = 3;
    // SummaryReplaySyncs
    hasi_id_event summary_replay_syncs = 4;
    // SummaryReplayNaks
    hasi_id_event summary_replay_naks = 5;
}

// HASI Master Object Client Info
message hasi_m_object_slave_info {
    // SlaveId
    uint32 slave_id = 1;
    // IdEvents
    hasi_m_id_events id_events = 2;
}

// HASI Master Object Context
message hasi_m_object_ctx {
    // ObjectSyncID
    uint64 object_sync_id = 1;
    // ObjectType
    uint32 object_type = 2;
    // Queue
    uint32 queue = 3;
    // CreateID
    uint64 create_id = 4;
    // CreateTime
    uint32 create_time = 5;
    // UpdateTime
    uint32 update_time = 6;
    // DeleteTime
    uint32 delete_time = 7;
    // DeleteContextLength
    uint32 delete_ctx_lenght = 8;
    // SlaveInformation
    repeated hasi_m_object_slave_info slave_information = 9;
    // HasHistory
    bool has_history = 10;
    // PreActiveHistory
    hasi_s_obj_id_events pre_active_history = 11;
}

// Per object HASI information
message l2vpn_sync_hasi_object {
    // Object Type Name
    string obj_name = 1;
    // Master Context
    hasi_m_object_ctx master_context = 2;
    // Slave Context
    hasi_s_object_ctx slave_context = 3;
    // Do/Do not have Hasi info
    bool in_hasi = 4;
}

message l2vpn_ethernet {
    // XConnect tags
    uint32 x_connect_tags = 1;
}

// EFP range
message l2vpn_efp_range {
    uint32 lower = 1;
    uint32 upper = 2;
}

message l2vpn_vlan {
    // XConnect tags
    uint32 x_connect_tags = 1;
    // VLAN rewrite tag
    uint32 vlan_rewrite_tag = 2;
    // Simple EFP
    uint32 simple_efp = 3;
    // Encapsulation Type
    uint32 encapsulation_type = 4;
    // Outer Tag
    uint32 outer_tag = 5;
    repeated l2vpn_efp_range vlan_ranges = 6;
}

message l2vpn_atm {
    // Max number of cells packed
    uint32 maximum_number_cells_packed = 1;
    // Max number of cells unpacked
    uint32 maximum_number_cells_un_packed = 2;
    // ATM mode
    string atm_mode = 3;
    // Virtual path identifier
    uint32 vpi = 4;
    // Virtual channel identifier
    uint32 vci = 5;
}

message l2vpn_fr {
    // Frame Relay mode
    string fr_mode = 1;
    // Data-link connection identifier
    uint32 dlci = 2;
}

message l2vpn_pwhe {
    // Is this Interface list valid
    bool is_valid = 1;
    // Interface list data
    item_iflist_ifl interface_list = 2;
    // Internal Label
    uint32 internal_label = 3;
}

// L2VPN TDM options
message l2vpn_tdm_option {
    // TDM payload bytes
    uint32 payload_bytes = 1;
    // TDM bit rate in units of Kbps
    uint32 bit_rate = 2;
    // RTP header
    string rtp = 3;
    // TDM Timestamping mode
    string timestamp_mode = 4;
    // Signalling packets
    uint32 signalling_packets = 5;
    // CAS
    uint32 cas = 6;
    // RTP header payload type
    uint32 rtp_header_payload_type = 7;
    // Timestamping clock frequency in units of 8Khz
    uint32 timestamp_clock_freq = 8;
    // Synchronization Source identifier
    uint32 ssrc = 9;
}

// L2VPN TDM parameters
message l2vpn_tdm {
    // Timeslots separated by , or - from 1 to 31. : indicates individual timeslot and - represents a range.E.g. 1-3,5 represents timeslots 1, 2, 3, and 5.
    string timeslot_group = 1;
    // Timeslot rate in units of Kbps
    uint32 timeslot_rate = 2;
    // TDM mode
    string tdm_mode = 3;
    // TDM options
    l2vpn_tdm_option tdm_options = 4;
}

message l2vpn_interface_params {
    string type = 1;
    // Ethernet
    l2vpn_ethernet ethernet = 2;
    // VLAN
    l2vpn_vlan vlan = 3;
    // TDM
    l2vpn_tdm tdm = 4;
    // ATM
    l2vpn_atm atm = 5;
    // Frame Relay
    l2vpn_fr fr = 6;
    // PW Ether
    l2vpn_pwhe pseudowire_ether = 7;
    // PW IW
    l2vpn_pwhe pseudowire_iw = 8;
}

message l2vpn_interface {
    // Interface name
    string name = 1;
    // Interface MTU
    uint32 mtu = 2;
    // Payload bytes
    uint32 payload_bytes = 3;
    // Interface parameters
    l2vpn_interface_params parameters = 4;
}

message l2vpn_vpls_id_auto {
    // 2 Byte AS Number
    uint32 asn = 1;
    // VPN ID
    uint32 vpn_id = 2;
}

message l2vpn_vpls_id_2byte_as {
    // 2 Byte AS Number
    uint32 two_byte_as = 1;
    // 4 Byte Index
    uint32 four_byte_index = 2;
}

message l2vpn_vpls_id_v4addr {
    // IPv4 Address
    string ipv4_address = 1;
    // 2 Byte Index
    uint32 two_byte_index = 2;
}

message l2vpn_vpls_id {
    string vpls_id_type = 1;
    l2vpn_vpls_id_auto auto = 2;
    l2vpn_vpls_id_2byte_as two_byte_as = 3;
    l2vpn_vpls_id_v4addr v4_addr = 4;
}

message l2vpn_atom {
    // Is this connected to a PW-HE AC
    bool is_pseudowire_headend = 1;
    // Local label
    uint32 local_label = 2;
    // Remote label
    uint32 remote_label = 3;
    // Local group ID
    uint32 local_group_id = 4;
    // Remote group ID
    uint32 remote_group_id = 5;
    // Local VCCV CV type
    uint32 local_cv_type = 6;
    // Local VCCV CC type
    uint32 local_cc_type = 7;
    // Remote VCCV CV type
    uint32 remote_cv_type = 8;
    // Remote VCCV CC type
    uint32 remote_cc_type = 9;
    // Local VE ID
    uint32 local_veid = 10;
    // Remote VE ID
    uint32 remote_veid = 11;
    // Local CE ID
    uint32 local_ceid = 12;
    // Remote CE ID
    uint32 remote_ceid = 13;
    // Local BGP source address
    string source_address = 14;
    // Remote BGP source address
    string remote_source_address = 15;
    // Local LDP ID
    string local_ldp_id = 16;
    // Remote LDP ID
    string remote_ldp_id = 17;
    // Source Attachment Individual Identifer
    string saii = 18;
    // Target Attachment Individual Identifer
    string taii = 19;
    // Local Attachment Group Identifier
    l2vpn_vpls_id local_agi = 20;
    // Remote Attachment Group Identifier
    l2vpn_vpls_id remote_agi = 21;
    // Is SAII FEC129 Type 2
    bool is_sai_itype2 = 22;
    // Local SAII Global ID
    uint32 local_saii_gbl_id = 23;
    // Local SAII AC ID
    uint32 local_saiiac_id = 24;
    // Is TAII type 2
    bool is_tai_itype2 = 25;
    // Local TAII Global ID
    uint32 local_taii_gbl_id = 26;
    // Local TAII AC ID
    uint32 local_taiiac_id = 27;
    // Remote SAII Global ID
    uint32 rem_saii_gbl_id = 28;
    // Remote SAII AC ID
    uint32 rem_saiiac_id = 29;
    // Remote TAII Global ID
    uint32 rem_taii_gbl_id = 30;
    // Remote TAII AC ID
    uint32 rem_taiiac_id = 31;
    // Remote Source Attachment Individual Identifer
    string rem_saii = 32;
    // Remote Target Attachment Individual Identifer
    string rem_taii = 33;
    // LSD rewrite failed
    bool lsd_rewrite_failed = 34;
    // LDP label advertisment failed
    bool ldp_label_advertisment_failed = 35;
    // Multisegment pseudowire statistics
    l2fib_stats_bag_mspw multi_segment_pseudowire_stats = 36;
}

message l2vpn_l2tpv3 {
    string l2_tp_class_name = 1;
    // IPv4 source address
    string ipv4_source_address = 2;
    // IPv6 source address
    string ipv6_source_address = 3;
    // Path MTU enabled
    bool path_mtu_enabled = 4;
    // Path MTU Maximum allowable session MTU
    uint32 path_mtu_max_value = 5;
    // Don't Fragment Bit
    bool dont_fragment_bit = 6;
    // Type Of Service Mode
    string tos_mode = 7;
    // Type Of Service Value
    uint32 tos = 8;
    // Time To Live value
    uint32 ttl = 9;
    // Local session id
    uint32 local_session_id = 10;
    // Remote session id
    uint32 remote_session_id = 11;
    // Local cookie size: 0, 4, or 8 bytes
    uint32 local_cookie_size = 12;
    // Remote cookie size: 0, 4, or 8 bytes
    uint32 remote_cookie_size = 13;
    // Lower 4 bytes of the value of the local cookie
    uint32 local_cookie_low_value = 14;
    // Lower 4 bytes of the value of the remote cookie
    uint32 remote_cookie_low_value = 15;
    // Upper 4 bytes of the value of the local cookie
    uint32 local_cookie_high_value = 16;
    // Upper 4 bytes of the value of the remote cookie
    uint32 remote_cookie_high_value = 17;
    bool remote_circuit_status_up = 18;
    // L2TP tunnel state
    string tunnel_state = 19;
    // Local secondary cookie size: 0, 4, or 8 bytes
    uint32 local_secondary_cookie_size = 20;
    // Lower 4 bytes of the value of the local secondary cookie
    uint32 local_secondary_cookie_low_value = 21;
    // Upper 4 bytes of the value of the local secondary cookie
    uint32 local_secondary_cookie_high_value = 22;
}

message l2vpn_encap_pw {
    string encapsulation = 1;
    l2vpn_atom atom = 2;
    l2vpn_l2tpv3 l2_tpv3 = 3;
}

message l2vpn_pw_mpls_prefpath {
    string option = 1;
    uint32 next_hop_ip = 2;
    uint32 te_tunnel_interface_number = 3;
    uint32 ip_tunnel_interface_number = 4;
    uint32 tp_tunnel_interface_number = 5;
}

message l2vpn_pw_event_history {
    // The main code of the event.
    uint32 event = 1;
    // Event return value if applicable
    uint32 value = 2;
    // The time at which the event occured
    uint32 event_time = 3;
}

message l2vpn_ms_pw_tlv_info {
    // PW ID of last PW segment traversed
    uint32 pw_id = 1;
    // Local IP Address of PW Switching Point
    string local_address = 2;
    // Remote IP Address of Last PW Switching Point traversed
    string remote_address = 3;
    // PW Switching Point description
    string description = 4;
}

message l2vpn_ms_pw {
    // PW Status
    uint32 pw_status = 1;
    // Switching TLV info
    repeated l2vpn_ms_pw_tlv_info tlv = 2;
    // PW Status Switching TLV
    l2vpn_ms_pw_tlv_info status_tlv = 3;
}

message l2vpn_pw_evt {
    // The number of events injected
    uint32 number_of_events_injected = 1;
    repeated l2vpn_pw_event_history event_history = 2;
}

message l2vpn_p2mp_pw {
    // Local LSM info available
    bool local_available = 1;
    // Local Label
    uint32 local_label = 2;
    // Local P-Tree Type
    string local_p_tree_type = 3;
    // Local Tunnel ID
    uint32 local_tunnel_id = 4;
    // Local Extended Tunnel ID
    string local_extended_tunnel_id = 5;
    // Local P2MP ID
    uint32 local_p2_mp_id = 6;
    // Local Flags (see draft-ietf-l3vpn-2547bis-mcast-bgp-08)
    uint32 local_flags = 7;
    // Remote LSM info available
    bool remote_available = 8;
    // Remote Label
    uint32 remote_label = 9;
    // Remote P-Tree Type
    string remote_p_tree_type = 10;
    // Remote Tunnel ID
    uint32 remote_tunnel_id = 11;
    // Remote Extended Tunnel ID
    string remote_extended_tunnel_id = 12;
    // Remote P2MP ID
    uint32 remote_p2_mp_id = 13;
    // Remote Flags (see draft-ietf-l3vpn-2547bis-mcast-bgp-08)
    uint32 remote_flags = 14;
}

message l2vpn_bag_in6_addr_t {
    string value = 1;
}

message l2vpn_peer {
    string type = 1;
    // Peer IPv4 address
    string ipv4_peer_id = 2;
    // Peer IPv6 address
    l2vpn_bag_in6_addr_t ipv6_peer_id = 3;
    // Internal Label
    uint32 internal_label = 4;
}

message l2vpn_pw {
    // Peer
    l2vpn_peer peer_id = 1;
    // Local Source Address
    string local_source_address = 2;
    // Local IPv6 Source Address
    string ipv6_local_source_address = 3;
    // Pseudowire ID
    uint64 pseudo_wire_id = 4;
    // is Pseudowire-routed
    bool is_pwr_type = 5;
    // is EVPN VPWS
    bool is_evpnvpws_type = 6;
    // XConnect ID
    uint32 x_connect_id = 7;
    // State
    string state = 8;
    // Pseudowire state
    string pseudo_wire_state = 9;
    string protocol = 10;
    // Pseudowire class name
    string pw_class_name = 11;
    // StaticTagRewrite
    uint32 tag_rewrite = 12;
    // Interworking type
    string interworking = 13;
    // Pseudowire FEC type
    string fec_type = 14;
    // EVPN VPWS Source AC ID
    uint32 evpn_src_acid = 15;
    // Sequencing Type
    string sequencing_type = 16;
    // Resync if packets out of sequence
    bool resync_enabled = 17;
    // Number of Packets Out of Seqence to trigger resync
    uint32 resync_threshold = 18;
    // Encapsulation specific pseudowire information
    l2vpn_encap_pw encapsulation_info = 19;
    // Local control word
    string local_control_word = 20;
    // Remote control word
    string remote_control_word = 21;
    // Local pseudowire type
    string local_pseudo_wire_type = 22;
    // Remote pseudowire type
    string remote_pseudo_wire_type = 23;
    // Local interface
    l2vpn_interface local_interface = 24;
    // Remote interface
    l2vpn_interface remote_interface = 25;
    // Imposed vlan id
    uint32 imposed_vlan_id = 26;
    // Time when the pseudowire was created
    string time_created = 27;
    // Time elapsed since creation
    string time_elapsed_creation = 28;
    // Last time the pseudowire status changed
    string last_time_status_changed = 29;
    // Time elapsed since status changed
    string time_elapsed_status_changed = 30;
    // Last time the pseudowire went down in format %d/%m/%Y %H:%M:%S
    string last_time_status_down = 31;
    // Time elapsed since last status down in seconds
    uint32 time_elapsed_status_down = 32;
    // Shutdown
    bool shutdown = 33;
    // Pseudowire type mismatched
    bool pseudo_wire_type_mismatched = 34;
    // Payload bytes mismatched
    bool payload_bytes_mismatched = 35;
    // Bitrate mismatched
    bool bitrate_mismatched = 36;
    // RTP mismatched
    bool rtp_mismatched = 37;
    // Differential timestamp mismatched
    bool diff_ts_mismatched = 38;
    // Signalling packets mismatched
    bool sig_pkts_mismatched = 39;
    // CAS mismatched
    bool cas_mismatched = 40;
    // Payload bytes mismatched
    bool payload_type_mismatched = 41;
    // Frequency mismatched
    bool freq_mismatched = 42;
    // SSRC mismatched
    bool ssrc_mismatched = 43;
    // MTU mismatched
    bool mtu_mismatched = 44;
    // Illegal control word
    bool illegal_control_word = 45;
    // Auto-Discovered PW remote state down
    bool ad_remote_down = 46;
    // A true value indicates that QinQ is not supported with L2TPv3; A false value indicates that it is supported. Please note that this object has been deprecated and will be removed in the near future since QinQ is supported going forward.
    bool not_supported_qin_q = 47;
    // Failed to set BGP advertised local label
    bool local_label_failed = 48;
    // Failed to set BGP advertised remote label
    bool remote_label_failed = 49;
    // MPLS Preferred Path
    l2vpn_pw_mpls_prefpath preferred_path = 50;
    // Prefpath fallback enable/disable
    bool preferred_path_disable_fallback = 51;
    // TRUE if PW is a backup PW
    bool backup_pw = 52;
    // TRUE if PW is a primary PW
    bool primary_pw = 53;
    // TRUE if backup is active
    bool backup_active = 54;
    // TRUE if backup is active due to switchover
    bool backup_force_active = 55;
    // TRUE if backup is not automatically disabled
    bool disable_never = 56;
    // Backup disable delay
    uint32 disable_delay = 57;
    // Primary Peer IP address
    string primary_peer_id = 58;
    // Primary Pseudowire ID
    uint64 primary_pseudo_wire_id = 59;
    // Num MW messages sent over PW
    uint32 number_ma_cwithdraw_message_sent = 60;
    // Num MW messages received over PW
    uint32 num_ma_cwithdraw_msg_received = 61;
    // L2VPN Out of memory state
    uint32 out_of_memory_state = 62;
    // Oper down due to Transport LSP down
    bool transport_lsp_down = 63;
    // Oper down because MAC limit reached
    bool mac_limit_oper_down = 64;
    // PW status in use
    bool pw_status_use = 65;
    // Local signalling
    l2vpn_ms_pw local_signalling = 66;
    // Remote signalling
    l2vpn_ms_pw remote_signalling = 67;
    // Is autodiscovery
    bool auto_discovery = 68;
    // Autodiscovery method
    uint32 ad_method = 69;
    // LSD rewrite failed
    bool pwlsd_rewrite_failed = 70;
    // LDP label advertisment failed
    bool ldp_label_advertise_failed = 71;
    // Is VFI interface
    bool is_vfi = 72;
    // Is Multi-Segment Pseudowire
    bool is_multi_segment_pseudowire = 73;
    // Force one-way PW redundancy behaviour in Redundancy Group
    bool pw_redundancy_one_way = 74;
    // Statistics
    l2fib_stats_bag_forwarding statistics = 75;
    // Load Balance Type
    string load_balance = 76;
    // Negotiated pseudowire flow label type
    string pw_flow_label_type = 77;
    // Configured pseudowire flow label Type
    string pw_flow_label_type_cfg = 78;
    // Disable sending Code 17 TLV
    bool pw_flow_label_code17_disabled = 79;
    // is flow label static
    bool is_flow_label_static = 80;
    // Is Pseudowire partially programmed
    bool is_partially_programmed = 81;
    // Initial delay for redundant PW in seconds
    uint32 pw_redundancy_initial_delay = 82;
    // Oper down because Bridge has mismatched PW Types
    bool bridge_pw_type_mismatch = 83;
    // P2MP Pseudowire Information
    l2vpn_p2mp_pw p2_mp_pw = 84;
    // Required Bandwidth
    uint32 required_bw = 85;
    // Admited Bandwidth
    uint32 admited_bw = 86;
    // Forward Class attribute
    uint32 forward_class = 87;
    // Table-policy Name
    string table_policy_name = 88;
}

// Storm Control Configuration
message l2vpn_bag_storm_control_type {
    // Bridge Domain Policer
    bool bd_policer = 1;
    // Unknown-unicast Storm Control
    bool unicast = 2;
    // Multicast Storm Control
    bool multicast = 3;
    // Broadcast Storm Control
    bool broadcast = 4;
}

message l2vpn_bridge_sec_param {
    // MAC address limit
    uint32 mac_limit = 1;
    // MAC limit action
    string mac_limit_action = 2;
    // MAC limit notification
    string mac_limit_notification = 3;
    // MAC aging time in seconds
    uint32 mac_aging_time = 4;
    // MAC Aging Mode
    string mac_aging_mode = 5;
    // MAC flooding enabled
    bool mac_flooding = 6;
    // MAC learning enabled
    bool mac_learning = 7;
    // Learning disabled due to MAC limit action
    bool learn_disabled_mac_limit_action = 8;
    // Flooding of unknown-unicast disabled due to MAC limit action
    bool flood_uu_disabled_mac_limit_action = 9;
    // MAC limit reached
    bool mac_limit_reached = 10;
    // Flooding unknown unicast enabled
    bool flood_unknown_unicast_enabled = 11;
    // MAC Flush when port goes down
    bool mac_port_down_flush_enabled = 12;
    // Split Horizon Group ID
    uint32 split_horizon_group_id = 13;
    // Is IP Source Guard Enabled
    bool is_ip_source_guard_enabled = 14;
    // Is IP Source Guard Logging Enabled
    bool is_ipsg_logging_enabled = 15;
    // Is Dynamic ARP Inspection Enabled
    bool is_dai_enabled = 16;
    // Is DAI Logging Enabled
    bool is_dai_logging_enabled = 17;
    // Is DAI Source MAC Address Validation Enabled
    bool is_dai_addr_validate_source_mac_enabled = 18;
    // Is DAI Dstination MAC Address Validation Enabled
    bool is_dai_addr_validate_destination_mac_enabled = 19;
    // Is DAI IPv4 Addr Validation Enabled
    bool is_dai_addr_validate_ipv4_enabled = 20;
    // Is MAC Secure Enabled
    bool is_mac_secure_enabled = 21;
    // MAC Secure Action
    string mac_secure_action = 22;
    // Is MAC Secure Logging Enabled
    bool is_mac_secure_logging_enabled = 23;
    // Is MAC Secure Accept Shutdown Enabled (BP only)
    bool is_mac_secure_accept_shutdown_enabled = 24;
    // DAI Address Validation mask
    uint32 dai_address_validation_mask = 25;
    // DHCPv4 Snoop Status
    bool dhc_pv4_snoop = 26;
    // DHCPv4 Profile Name
    string dhc_pv4_profile_name = 27;
    // IGMPv4 Disabled
    bool igm_pv4_disabled = 28;
    // IGMPv4 Profile Name
    string igm_pv4_profile_name = 29;
    // MLD Profile Name
    string mld_profile_name = 30;
    // MMRP Flood Optimization Status
    bool mmrp_flood_optimization = 31;
    // Storm Control Configuration
    l2vpn_bag_storm_control_type storm_control = 32;
    // Unicast Storm Control Rate Unit
    string unicast_storm_control_rate_unit = 33;
    // Unicast Storm Control PPS
    uint64 unicast_storm_control_pps = 34;
    // Unicast Storm Control KbPS
    uint64 unicast_storm_control_kb_ps = 35;
    // Multicast Storm Control Rate Unit
    string multicast_storm_control_rate_unit = 36;
    // Multicast Storm Control PPS
    uint64 multicast_storm_control_pps = 37;
    // Multicast Storm Control KbPS
    uint64 multicast_storm_control_kb_ps = 38;
    // Broadcast Storm Control Rate Unit
    string broadcast_storm_control_rate_unit = 39;
    // Broadcast Storm Control PPS
    uint64 broadcast_storm_control_pps = 40;
    // Broadcast Storm Control KbPS
    uint64 broadcast_storm_control_kb_ps = 41;
}

message l2vpn_bridge_port_sec_param {
    // Basic Security Parameters
    l2vpn_bridge_sec_param base = 1;
    // Storm Control Configuration
    l2vpn_bag_storm_control_type storm_control = 2;
    // Unicast Storm Control Rate Unit
    string unicast_storm_control_rate_unit = 3;
    // Unicast Storm Control PPS
    uint64 unicast_storm_control_pps = 4;
    // Unicast Storm Control KbPS
    uint64 unicast_storm_control_kb_ps = 5;
    // Multicast Storm Control Rate Unit
    string multicast_storm_control_rate_unit = 6;
    // Multicast Storm Control PPS
    uint64 multicast_storm_control_pps = 7;
    // Multicast Storm Control KbPS
    uint64 multicast_storm_control_kb_ps = 8;
    // Broadcast Storm Control Rate Unit
    string broadcast_storm_control_rate_unit = 9;
    // Broadcast Storm Control PPS
    uint64 broadcast_storm_control_pps = 10;
    // Broadcast Storm Control KbPS
    uint64 broadcast_storm_control_kb_ps = 11;
    // DHCPv4 Trust Status
    bool dhc_pv4_trust = 12;
}

// L2VPN Static MAC Address
message l2vpn_bd_mac {
    // MAC address
    string address = 1;
    // Backbone MAC address
    string bmac = 2;
    // Next Hop IP
    string next_hop_ip = 3;
}

