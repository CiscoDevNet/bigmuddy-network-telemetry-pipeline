// Code generated by protoc-gen-go.
// source: ipv4_if_detail.proto
// DO NOT EDIT!

/*
Package cisco_ios_xr_ipv4_io_oper_ipv4_network_nodes_node_interface_data_vrfs_vrf_details_detail is a generated protocol buffer package.

It is generated from these files:
	ipv4_if_detail.proto

It has these top-level messages:
	Ipv4IfDetail_KEYS
	Ipv4IfDetail
	Str
	McastGroup
	IpAddrNode
	AclConfig
	MultiAclConfig
	HaddrArray
	RpfConfig
	BgpPaDir
	BgpPaConfig
	TimevalEntry
*/
package cisco_ios_xr_ipv4_io_oper_ipv4_network_nodes_node_interface_data_vrfs_vrf_details_detail

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Detailed Info of IP Interface
type Ipv4IfDetail_KEYS struct {
	NodeName      string `protobuf:"bytes,1,opt,name=node_name,json=nodeName" json:"node_name,omitempty"`
	VrfName       string `protobuf:"bytes,2,opt,name=vrf_name,json=vrfName" json:"vrf_name,omitempty"`
	InterfaceName string `protobuf:"bytes,3,opt,name=interface_name,json=interfaceName" json:"interface_name,omitempty"`
}

func (m *Ipv4IfDetail_KEYS) Reset()                    { *m = Ipv4IfDetail_KEYS{} }
func (m *Ipv4IfDetail_KEYS) String() string            { return proto.CompactTextString(m) }
func (*Ipv4IfDetail_KEYS) ProtoMessage()               {}
func (*Ipv4IfDetail_KEYS) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Ipv4IfDetail_KEYS) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *Ipv4IfDetail_KEYS) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *Ipv4IfDetail_KEYS) GetInterfaceName() string {
	if m != nil {
		return m.InterfaceName
	}
	return ""
}

type Ipv4IfDetail struct {
	// Primary address
	PrimaryAddress string `protobuf:"bytes,50,opt,name=primary_address,json=primaryAddress" json:"primary_address,omitempty"`
	// VRF ID of the interface
	VrfId uint32 `protobuf:"varint,51,opt,name=vrf_id,json=vrfId" json:"vrf_id,omitempty"`
	// Line state of the interface
	LineState string `protobuf:"bytes,52,opt,name=line_state,json=lineState" json:"line_state,omitempty"`
	// Prefix length of primary address
	PrefixLength uint32 `protobuf:"varint,53,opt,name=prefix_length,json=prefixLength" json:"prefix_length,omitempty"`
	// Route tag associated with the primary address (0 = no tag)
	RouteTag uint32 `protobuf:"varint,54,opt,name=route_tag,json=routeTag" json:"route_tag,omitempty"`
	// Multicast groups joined on the interface
	MulticastGroups []*McastGroup `protobuf:"bytes,55,rep,name=multicast_groups,json=multicastGroups" json:"multicast_groups,omitempty"`
	// IP MTU of the interface
	Mtu uint32 `protobuf:"varint,56,opt,name=mtu" json:"mtu,omitempty"`
	// Are ICMP unreachables sent on the interface?
	Unreachable bool `protobuf:"varint,57,opt,name=unreachable" json:"unreachable,omitempty"`
	// Are ICMP redirects sent on the interface?
	Redirect bool `protobuf:"varint,58,opt,name=redirect" json:"redirect,omitempty"`
	// Are direct broadcasts sent on the interface?
	DirectBroadcast bool `protobuf:"varint,59,opt,name=direct_broadcast,json=directBroadcast" json:"direct_broadcast,omitempty"`
	// Are mask replies sent on the interface?
	MaskReply bool `protobuf:"varint,60,opt,name=mask_reply,json=maskReply" json:"mask_reply,omitempty"`
	// Does ICCP RG ID exist on the interface?
	RgIdExists bool `protobuf:"varint,61,opt,name=rg_id_exists,json=rgIdExists" json:"rg_id_exists,omitempty"`
	// Is mLACP state Active (valid if RG ID exists)
	MLacpActive bool `protobuf:"varint,62,opt,name=m_lacp_active,json=mLacpActive" json:"m_lacp_active,omitempty"`
	// Name of referenced interface (valid if unnumbered)
	UnnumberedInterfaceName string `protobuf:"bytes,63,opt,name=unnumbered_interface_name,json=unnumberedInterfaceName" json:"unnumbered_interface_name,omitempty"`
	// Secondary addresses on the interface
	SecondaryAddress []*IpAddrNode `protobuf:"bytes,64,rep,name=secondary_address,json=secondaryAddress" json:"secondary_address,omitempty"`
	// Is Proxy ARP disabled on the interface?
	ProxyArpDisabled bool `protobuf:"varint,65,opt,name=proxy_arp_disabled,json=proxyArpDisabled" json:"proxy_arp_disabled,omitempty"`
	// ACLs configured on the interface
	Acl *AclConfig `protobuf:"bytes,66,opt,name=acl" json:"acl,omitempty"`
	// Multi ACLs configured on the interface
	MultiAcl *MultiAclConfig `protobuf:"bytes,67,opt,name=multi_acl,json=multiAcl" json:"multi_acl,omitempty"`
	// Helper Addresses configured on the interface
	HelperAddress *HaddrArray `protobuf:"bytes,68,opt,name=helper_address,json=helperAddress" json:"helper_address,omitempty"`
	// RPF config on the interface
	Rpf *RpfConfig `protobuf:"bytes,69,opt,name=rpf" json:"rpf,omitempty"`
	// BGP PA config on the interface
	BgpPa *BgpPaConfig `protobuf:"bytes,70,opt,name=bgp_pa,json=bgpPa" json:"bgp_pa,omitempty"`
	// Is BGP Flow Tag Source is enable
	FlowTagSrc bool `protobuf:"varint,71,opt,name=flow_tag_src,json=flowTagSrc" json:"flow_tag_src,omitempty"`
	// Is BGP Flow Tag Destination is enable
	FlowTagDst bool `protobuf:"varint,72,opt,name=flow_tag_dst,json=flowTagDst" json:"flow_tag_dst,omitempty"`
	// Address Publish Time
	PubUtime *TimevalEntry `protobuf:"bytes,73,opt,name=pub_utime,json=pubUtime" json:"pub_utime,omitempty"`
	// IDB Create Time
	IdbUtime *TimevalEntry `protobuf:"bytes,74,opt,name=idb_utime,json=idbUtime" json:"idb_utime,omitempty"`
	// CAPS Add Time
	CapsUtime *TimevalEntry `protobuf:"bytes,75,opt,name=caps_utime,json=capsUtime" json:"caps_utime,omitempty"`
	// FWD ENABLE Time
	FwdEnUtime *TimevalEntry `protobuf:"bytes,76,opt,name=fwd_en_utime,json=fwdEnUtime" json:"fwd_en_utime,omitempty"`
	// FWD DISABLE Time
	FwdDisUtime *TimevalEntry `protobuf:"bytes,77,opt,name=fwd_dis_utime,json=fwdDisUtime" json:"fwd_dis_utime,omitempty"`
}

func (m *Ipv4IfDetail) Reset()                    { *m = Ipv4IfDetail{} }
func (m *Ipv4IfDetail) String() string            { return proto.CompactTextString(m) }
func (*Ipv4IfDetail) ProtoMessage()               {}
func (*Ipv4IfDetail) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Ipv4IfDetail) GetPrimaryAddress() string {
	if m != nil {
		return m.PrimaryAddress
	}
	return ""
}

func (m *Ipv4IfDetail) GetVrfId() uint32 {
	if m != nil {
		return m.VrfId
	}
	return 0
}

func (m *Ipv4IfDetail) GetLineState() string {
	if m != nil {
		return m.LineState
	}
	return ""
}

func (m *Ipv4IfDetail) GetPrefixLength() uint32 {
	if m != nil {
		return m.PrefixLength
	}
	return 0
}

func (m *Ipv4IfDetail) GetRouteTag() uint32 {
	if m != nil {
		return m.RouteTag
	}
	return 0
}

func (m *Ipv4IfDetail) GetMulticastGroups() []*McastGroup {
	if m != nil {
		return m.MulticastGroups
	}
	return nil
}

func (m *Ipv4IfDetail) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *Ipv4IfDetail) GetUnreachable() bool {
	if m != nil {
		return m.Unreachable
	}
	return false
}

func (m *Ipv4IfDetail) GetRedirect() bool {
	if m != nil {
		return m.Redirect
	}
	return false
}

func (m *Ipv4IfDetail) GetDirectBroadcast() bool {
	if m != nil {
		return m.DirectBroadcast
	}
	return false
}

func (m *Ipv4IfDetail) GetMaskReply() bool {
	if m != nil {
		return m.MaskReply
	}
	return false
}

func (m *Ipv4IfDetail) GetRgIdExists() bool {
	if m != nil {
		return m.RgIdExists
	}
	return false
}

func (m *Ipv4IfDetail) GetMLacpActive() bool {
	if m != nil {
		return m.MLacpActive
	}
	return false
}

func (m *Ipv4IfDetail) GetUnnumberedInterfaceName() string {
	if m != nil {
		return m.UnnumberedInterfaceName
	}
	return ""
}

func (m *Ipv4IfDetail) GetSecondaryAddress() []*IpAddrNode {
	if m != nil {
		return m.SecondaryAddress
	}
	return nil
}

func (m *Ipv4IfDetail) GetProxyArpDisabled() bool {
	if m != nil {
		return m.ProxyArpDisabled
	}
	return false
}

func (m *Ipv4IfDetail) GetAcl() *AclConfig {
	if m != nil {
		return m.Acl
	}
	return nil
}

func (m *Ipv4IfDetail) GetMultiAcl() *MultiAclConfig {
	if m != nil {
		return m.MultiAcl
	}
	return nil
}

func (m *Ipv4IfDetail) GetHelperAddress() *HaddrArray {
	if m != nil {
		return m.HelperAddress
	}
	return nil
}

func (m *Ipv4IfDetail) GetRpf() *RpfConfig {
	if m != nil {
		return m.Rpf
	}
	return nil
}

func (m *Ipv4IfDetail) GetBgpPa() *BgpPaConfig {
	if m != nil {
		return m.BgpPa
	}
	return nil
}

func (m *Ipv4IfDetail) GetFlowTagSrc() bool {
	if m != nil {
		return m.FlowTagSrc
	}
	return false
}

func (m *Ipv4IfDetail) GetFlowTagDst() bool {
	if m != nil {
		return m.FlowTagDst
	}
	return false
}

func (m *Ipv4IfDetail) GetPubUtime() *TimevalEntry {
	if m != nil {
		return m.PubUtime
	}
	return nil
}

func (m *Ipv4IfDetail) GetIdbUtime() *TimevalEntry {
	if m != nil {
		return m.IdbUtime
	}
	return nil
}

func (m *Ipv4IfDetail) GetCapsUtime() *TimevalEntry {
	if m != nil {
		return m.CapsUtime
	}
	return nil
}

func (m *Ipv4IfDetail) GetFwdEnUtime() *TimevalEntry {
	if m != nil {
		return m.FwdEnUtime
	}
	return nil
}

func (m *Ipv4IfDetail) GetFwdDisUtime() *TimevalEntry {
	if m != nil {
		return m.FwdDisUtime
	}
	return nil
}

type Str struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
}

func (m *Str) Reset()                    { *m = Str{} }
func (m *Str) String() string            { return proto.CompactTextString(m) }
func (*Str) ProtoMessage()               {}
func (*Str) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Str) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// MCast Group List
type McastGroup struct {
	// Address of multicast group
	GroupAddress string `protobuf:"bytes,1,opt,name=group_address,json=groupAddress" json:"group_address,omitempty"`
}

func (m *McastGroup) Reset()                    { *m = McastGroup{} }
func (m *McastGroup) String() string            { return proto.CompactTextString(m) }
func (*McastGroup) ProtoMessage()               {}
func (*McastGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *McastGroup) GetGroupAddress() string {
	if m != nil {
		return m.GroupAddress
	}
	return ""
}

// List of IP Addresses
type IpAddrNode struct {
	// Address
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// Prefix length of address
	PrefixLength uint32 `protobuf:"varint,2,opt,name=prefix_length,json=prefixLength" json:"prefix_length,omitempty"`
	// Route Tag associated with this address (0 = no tag)
	RouteTag uint32 `protobuf:"varint,3,opt,name=route_tag,json=routeTag" json:"route_tag,omitempty"`
}

func (m *IpAddrNode) Reset()                    { *m = IpAddrNode{} }
func (m *IpAddrNode) String() string            { return proto.CompactTextString(m) }
func (*IpAddrNode) ProtoMessage()               {}
func (*IpAddrNode) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *IpAddrNode) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *IpAddrNode) GetPrefixLength() uint32 {
	if m != nil {
		return m.PrefixLength
	}
	return 0
}

func (m *IpAddrNode) GetRouteTag() uint32 {
	if m != nil {
		return m.RouteTag
	}
	return 0
}

// ACL config information
type AclConfig struct {
	// ACL applied to incoming packets
	Inbound string `protobuf:"bytes,1,opt,name=inbound" json:"inbound,omitempty"`
	// ACL applied to outgoing packets
	Outbound string `protobuf:"bytes,2,opt,name=outbound" json:"outbound,omitempty"`
	// Common ACL applied to incoming packets
	CommonInBound string `protobuf:"bytes,3,opt,name=common_in_bound,json=commonInBound" json:"common_in_bound,omitempty"`
	// Common ACL applied to outgoing packets
	CommonOutBound string `protobuf:"bytes,4,opt,name=common_out_bound,json=commonOutBound" json:"common_out_bound,omitempty"`
}

func (m *AclConfig) Reset()                    { *m = AclConfig{} }
func (m *AclConfig) String() string            { return proto.CompactTextString(m) }
func (*AclConfig) ProtoMessage()               {}
func (*AclConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *AclConfig) GetInbound() string {
	if m != nil {
		return m.Inbound
	}
	return ""
}

func (m *AclConfig) GetOutbound() string {
	if m != nil {
		return m.Outbound
	}
	return ""
}

func (m *AclConfig) GetCommonInBound() string {
	if m != nil {
		return m.CommonInBound
	}
	return ""
}

func (m *AclConfig) GetCommonOutBound() string {
	if m != nil {
		return m.CommonOutBound
	}
	return ""
}

// Multi ACL config information
type MultiAclConfig struct {
	// Inbound ACLs
	Inbound []*Str `protobuf:"bytes,1,rep,name=inbound" json:"inbound,omitempty"`
	// Outbound ACLs
	Outbound []*Str `protobuf:"bytes,2,rep,name=outbound" json:"outbound,omitempty"`
	// Common ACLs
	Common []*Str `protobuf:"bytes,3,rep,name=common" json:"common,omitempty"`
}

func (m *MultiAclConfig) Reset()                    { *m = MultiAclConfig{} }
func (m *MultiAclConfig) String() string            { return proto.CompactTextString(m) }
func (*MultiAclConfig) ProtoMessage()               {}
func (*MultiAclConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *MultiAclConfig) GetInbound() []*Str {
	if m != nil {
		return m.Inbound
	}
	return nil
}

func (m *MultiAclConfig) GetOutbound() []*Str {
	if m != nil {
		return m.Outbound
	}
	return nil
}

func (m *MultiAclConfig) GetCommon() []*Str {
	if m != nil {
		return m.Common
	}
	return nil
}

// Helper Address List
type HaddrArray struct {
	// Helper address
	AddressArray [][]byte `protobuf:"bytes,1,rep,name=address_array,json=addressArray,proto3" json:"address_array,omitempty"`
}

func (m *HaddrArray) Reset()                    { *m = HaddrArray{} }
func (m *HaddrArray) String() string            { return proto.CompactTextString(m) }
func (*HaddrArray) ProtoMessage()               {}
func (*HaddrArray) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *HaddrArray) GetAddressArray() [][]byte {
	if m != nil {
		return m.AddressArray
	}
	return nil
}

// RPF config information
type RpfConfig struct {
	// Enable RPF config
	Enable bool `protobuf:"varint,1,opt,name=enable" json:"enable,omitempty"`
	// Allow Default Route
	AllowDefaultRoute bool `protobuf:"varint,2,opt,name=allow_default_route,json=allowDefaultRoute" json:"allow_default_route,omitempty"`
	// Allow Self Ping
	AllowSelfPing bool `protobuf:"varint,3,opt,name=allow_self_ping,json=allowSelfPing" json:"allow_self_ping,omitempty"`
	// RPF Mode (loose/strict)
	Mode string `protobuf:"bytes,4,opt,name=mode" json:"mode,omitempty"`
}

func (m *RpfConfig) Reset()                    { *m = RpfConfig{} }
func (m *RpfConfig) String() string            { return proto.CompactTextString(m) }
func (*RpfConfig) ProtoMessage()               {}
func (*RpfConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *RpfConfig) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *RpfConfig) GetAllowDefaultRoute() bool {
	if m != nil {
		return m.AllowDefaultRoute
	}
	return false
}

func (m *RpfConfig) GetAllowSelfPing() bool {
	if m != nil {
		return m.AllowSelfPing
	}
	return false
}

func (m *RpfConfig) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

// BGP PA config for ingress/egress direction
type BgpPaDir struct {
	// Enable BGP PA for ingress/egress
	Enable bool `protobuf:"varint,1,opt,name=enable" json:"enable,omitempty"`
	// Enable source accouting
	Source bool `protobuf:"varint,2,opt,name=source" json:"source,omitempty"`
	// Enable destination accouting
	Destination bool `protobuf:"varint,3,opt,name=destination" json:"destination,omitempty"`
}

func (m *BgpPaDir) Reset()                    { *m = BgpPaDir{} }
func (m *BgpPaDir) String() string            { return proto.CompactTextString(m) }
func (*BgpPaDir) ProtoMessage()               {}
func (*BgpPaDir) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *BgpPaDir) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *BgpPaDir) GetSource() bool {
	if m != nil {
		return m.Source
	}
	return false
}

func (m *BgpPaDir) GetDestination() bool {
	if m != nil {
		return m.Destination
	}
	return false
}

// BGP PA config information
type BgpPaConfig struct {
	// BGP PA input config
	Input *BgpPaDir `protobuf:"bytes,1,opt,name=input" json:"input,omitempty"`
	// BGP PA output config
	Output *BgpPaDir `protobuf:"bytes,2,opt,name=output" json:"output,omitempty"`
}

func (m *BgpPaConfig) Reset()                    { *m = BgpPaConfig{} }
func (m *BgpPaConfig) String() string            { return proto.CompactTextString(m) }
func (*BgpPaConfig) ProtoMessage()               {}
func (*BgpPaConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *BgpPaConfig) GetInput() *BgpPaDir {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *BgpPaConfig) GetOutput() *BgpPaDir {
	if m != nil {
		return m.Output
	}
	return nil
}

// Creation or Update Time
type TimevalEntry struct {
}

func (m *TimevalEntry) Reset()                    { *m = TimevalEntry{} }
func (m *TimevalEntry) String() string            { return proto.CompactTextString(m) }
func (*TimevalEntry) ProtoMessage()               {}
func (*TimevalEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func init() {
	proto.RegisterType((*Ipv4IfDetail_KEYS)(nil), "cisco_ios_xr_ipv4_io_oper.ipv4_network.nodes.node.interface_data.vrfs.vrf.details.detail.ipv4_if_detail_KEYS")
	proto.RegisterType((*Ipv4IfDetail)(nil), "cisco_ios_xr_ipv4_io_oper.ipv4_network.nodes.node.interface_data.vrfs.vrf.details.detail.ipv4_if_detail")
	proto.RegisterType((*Str)(nil), "cisco_ios_xr_ipv4_io_oper.ipv4_network.nodes.node.interface_data.vrfs.vrf.details.detail.str")
	proto.RegisterType((*McastGroup)(nil), "cisco_ios_xr_ipv4_io_oper.ipv4_network.nodes.node.interface_data.vrfs.vrf.details.detail.mcast_group")
	proto.RegisterType((*IpAddrNode)(nil), "cisco_ios_xr_ipv4_io_oper.ipv4_network.nodes.node.interface_data.vrfs.vrf.details.detail.ip_addr_node")
	proto.RegisterType((*AclConfig)(nil), "cisco_ios_xr_ipv4_io_oper.ipv4_network.nodes.node.interface_data.vrfs.vrf.details.detail.acl_config")
	proto.RegisterType((*MultiAclConfig)(nil), "cisco_ios_xr_ipv4_io_oper.ipv4_network.nodes.node.interface_data.vrfs.vrf.details.detail.multi_acl_config")
	proto.RegisterType((*HaddrArray)(nil), "cisco_ios_xr_ipv4_io_oper.ipv4_network.nodes.node.interface_data.vrfs.vrf.details.detail.haddr_array")
	proto.RegisterType((*RpfConfig)(nil), "cisco_ios_xr_ipv4_io_oper.ipv4_network.nodes.node.interface_data.vrfs.vrf.details.detail.rpf_config")
	proto.RegisterType((*BgpPaDir)(nil), "cisco_ios_xr_ipv4_io_oper.ipv4_network.nodes.node.interface_data.vrfs.vrf.details.detail.bgp_pa_dir")
	proto.RegisterType((*BgpPaConfig)(nil), "cisco_ios_xr_ipv4_io_oper.ipv4_network.nodes.node.interface_data.vrfs.vrf.details.detail.bgp_pa_config")
	proto.RegisterType((*TimevalEntry)(nil), "cisco_ios_xr_ipv4_io_oper.ipv4_network.nodes.node.interface_data.vrfs.vrf.details.detail.timeval_entry")
}

func init() { proto.RegisterFile("ipv4_if_detail.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1136 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0x5d, 0x6f, 0x1b, 0x45,
	0x14, 0xd5, 0xc6, 0x8d, 0x6b, 0xdf, 0xd8, 0x49, 0x3a, 0x2d, 0x65, 0x4b, 0x85, 0x64, 0x19, 0x01,
	0x41, 0x42, 0x7e, 0x48, 0xcb, 0x57, 0xf9, 0x4c, 0x49, 0x28, 0xa1, 0x05, 0xaa, 0x4d, 0x91, 0xe0,
	0x01, 0x46, 0xe3, 0x9d, 0x59, 0x67, 0xda, 0xdd, 0xd9, 0xd1, 0xcc, 0xac, 0x93, 0x20, 0xc4, 0x13,
	0x02, 0x55, 0xf0, 0x50, 0x09, 0x7e, 0x01, 0xff, 0x13, 0x09, 0xcd, 0x9d, 0x5d, 0x7f, 0x80, 0x10,
	0x4f, 0xf6, 0x8b, 0xb3, 0x73, 0xee, 0x59, 0x9f, 0x33, 0x73, 0xaf, 0xe7, 0xde, 0xc0, 0x35, 0xa9,
	0xa7, 0xb7, 0xa9, 0xcc, 0x28, 0x17, 0x8e, 0xc9, 0x7c, 0xa4, 0x4d, 0xe9, 0x4a, 0xf2, 0x75, 0x2a,
	0x6d, 0x5a, 0x52, 0x59, 0x5a, 0x7a, 0x6e, 0x68, 0xa0, 0x94, 0xb4, 0xd4, 0xc2, 0x8c, 0x70, 0xa1,
	0x84, 0x3b, 0x2b, 0xcd, 0x93, 0x91, 0x2a, 0xb9, 0xb0, 0xf8, 0x39, 0x92, 0xca, 0x09, 0x93, 0xb1,
	0x54, 0x50, 0xce, 0x1c, 0x1b, 0x4d, 0x4d, 0x66, 0xfd, 0xc7, 0x28, 0x7c, 0xaf, 0xad, 0xff, 0x0e,
	0x1d, 0x5c, 0x5d, 0x56, 0xa4, 0xf7, 0x8f, 0xbe, 0x39, 0x21, 0x37, 0xa1, 0xeb, 0xbf, 0x85, 0x2a,
	0x56, 0x88, 0x38, 0x1a, 0x44, 0x7b, 0xdd, 0xa4, 0xe3, 0x81, 0x2f, 0x58, 0x21, 0xc8, 0x0d, 0xe8,
	0x4c, 0x4d, 0x16, 0x62, 0x1b, 0x18, 0xbb, 0x3c, 0x35, 0x19, 0x86, 0x5e, 0x86, 0xed, 0xb9, 0x30,
	0x12, 0x5a, 0x48, 0xe8, 0xcf, 0x50, 0x4f, 0x1b, 0xfe, 0x79, 0x05, 0xb6, 0x97, 0x65, 0xc9, 0xab,
	0xb0, 0xa3, 0x8d, 0x2c, 0x98, 0xb9, 0xa0, 0x8c, 0x73, 0x23, 0xac, 0x8d, 0xf7, 0xf1, 0xd5, 0xed,
	0x1a, 0x3e, 0x08, 0x28, 0x79, 0x0e, 0xda, 0x5e, 0x5d, 0xf2, 0xf8, 0xd6, 0x20, 0xda, 0xeb, 0x27,
	0x9b, 0x53, 0x93, 0x1d, 0x73, 0xf2, 0x22, 0x40, 0x2e, 0x95, 0xa0, 0xd6, 0x31, 0x27, 0xe2, 0xdb,
	0xf8, 0x6a, 0xd7, 0x23, 0x27, 0x1e, 0x20, 0x2f, 0x41, 0x5f, 0x1b, 0x91, 0xc9, 0x73, 0x9a, 0x0b,
	0x35, 0x71, 0xa7, 0xf1, 0x1b, 0xf8, 0x72, 0x2f, 0x80, 0x0f, 0x10, 0xf3, 0xbb, 0x36, 0x65, 0xe5,
	0x04, 0x75, 0x6c, 0x12, 0xbf, 0x89, 0x84, 0x0e, 0x02, 0x8f, 0xd8, 0x84, 0x3c, 0x8b, 0x60, 0xb7,
	0xa8, 0x72, 0x27, 0x53, 0x66, 0x1d, 0x9d, 0x98, 0xb2, 0xd2, 0x36, 0x7e, 0x6b, 0xd0, 0xda, 0xdb,
	0xda, 0x17, 0xa3, 0x55, 0xe5, 0x67, 0x54, 0xcc, 0xd5, 0x92, 0x9d, 0x99, 0xfc, 0x3d, 0x54, 0x27,
	0xbb, 0xd0, 0x2a, 0x5c, 0x15, 0xbf, 0x8d, 0x4e, 0xfd, 0x23, 0x19, 0xc0, 0x56, 0xa5, 0x8c, 0x60,
	0xe9, 0x29, 0x1b, 0xe7, 0x22, 0x7e, 0x67, 0x10, 0xed, 0x75, 0x92, 0x45, 0x88, 0xbc, 0x00, 0x1d,
	0x23, 0xb8, 0x34, 0x22, 0x75, 0xf1, 0x1d, 0x0c, 0xcf, 0xd6, 0xe4, 0x35, 0xd8, 0x0d, 0x4f, 0x74,
	0x6c, 0x4a, 0xc6, 0xbd, 0x52, 0xfc, 0x2e, 0x72, 0x76, 0x02, 0x7e, 0xb7, 0x81, 0xfd, 0x71, 0x17,
	0xcc, 0x3e, 0xa1, 0x46, 0xe8, 0xfc, 0x22, 0x7e, 0x0f, 0x49, 0x5d, 0x8f, 0x24, 0x1e, 0x20, 0x03,
	0xe8, 0x99, 0x09, 0x95, 0x9c, 0x8a, 0x73, 0x69, 0x9d, 0x8d, 0xdf, 0x47, 0x02, 0x98, 0xc9, 0x31,
	0x3f, 0x42, 0x84, 0x0c, 0xa1, 0x5f, 0xd0, 0x9c, 0xa5, 0x9a, 0xb2, 0xd4, 0xc9, 0xa9, 0x88, 0x3f,
	0x08, 0x5e, 0x8b, 0x07, 0x2c, 0xd5, 0x07, 0x08, 0x91, 0x3b, 0x70, 0xa3, 0x52, 0xaa, 0x2a, 0xc6,
	0xc2, 0x08, 0x4e, 0xff, 0x51, 0x58, 0x1f, 0x62, 0x8a, 0x9f, 0x9f, 0x13, 0x8e, 0x17, 0x4b, 0x8c,
	0xfc, 0x1e, 0xc1, 0x15, 0x2b, 0xd2, 0x52, 0xf1, 0xc5, 0x92, 0xfa, 0x08, 0xf3, 0x95, 0xad, 0x2e,
	0x5f, 0x52, 0xa3, 0x16, 0xf5, 0xef, 0x24, 0xbb, 0x33, 0x03, 0x4d, 0xf1, 0xbe, 0x0e, 0x44, 0x9b,
	0xf2, 0xfc, 0x82, 0x32, 0xa3, 0x29, 0x97, 0xd6, 0xa7, 0x84, 0xc7, 0x07, 0xb8, 0xf5, 0x5d, 0x8c,
	0x1c, 0x18, 0x7d, 0x58, 0xe3, 0x64, 0x0a, 0x2d, 0x96, 0xe6, 0xf1, 0xdd, 0x41, 0xb4, 0xb7, 0xb5,
	0xcf, 0x57, 0x67, 0x9a, 0xa5, 0x39, 0x4d, 0x4b, 0x95, 0xc9, 0x49, 0xe2, 0x05, 0xc9, 0x2f, 0x11,
	0x74, 0xb1, 0xd6, 0xa8, 0x97, 0xff, 0x18, 0xe5, 0x1f, 0xaf, 0xb0, 0xc6, 0x1b, 0xa9, 0xc6, 0x44,
	0x07, 0x91, 0x83, 0x34, 0x27, 0xbf, 0x45, 0xb0, 0x7d, 0x2a, 0x72, 0x2d, 0xcc, 0x2c, 0x85, 0x87,
	0x68, 0x67, 0x85, 0x3f, 0xb9, 0x53, 0x4c, 0x20, 0x33, 0x86, 0x5d, 0x24, 0xfd, 0x20, 0xde, 0xa4,
	0x6f, 0x0a, 0x2d, 0xa3, 0xb3, 0xf8, 0x68, 0xd5, 0x09, 0x31, 0x3a, 0x9b, 0x25, 0xc4, 0xe8, 0x8c,
	0xfc, 0x08, 0xed, 0xf1, 0x44, 0x53, 0xcd, 0xe2, 0x4f, 0x50, 0x7a, 0xb2, 0x3a, 0xe9, 0xa0, 0xd3,
	0xa8, 0x6f, 0x8e, 0x27, 0xfa, 0x21, 0xf3, 0x3f, 0xe7, 0x2c, 0x2f, 0xcf, 0xfc, 0xbd, 0x48, 0xad,
	0x49, 0xe3, 0x7b, 0xe1, 0xe7, 0xec, 0xb1, 0x47, 0x6c, 0x72, 0x62, 0xd2, 0x25, 0x06, 0xb7, 0x2e,
	0xfe, 0x74, 0x89, 0x71, 0x68, 0x1d, 0xf9, 0x29, 0x82, 0xae, 0xae, 0xc6, 0xb4, 0x72, 0xb2, 0x10,
	0xf1, 0xf1, 0xaa, 0xf7, 0xe1, 0x55, 0xa6, 0x2c, 0xa7, 0x42, 0x39, 0x73, 0x91, 0x74, 0x74, 0x35,
	0xfe, 0xca, 0x43, 0x68, 0x43, 0xf2, 0xc6, 0xc6, 0x67, 0x6b, 0xb6, 0x21, 0x79, 0x6d, 0xe3, 0xe7,
	0x08, 0x20, 0x65, 0xda, 0xd6, 0x3e, 0xee, 0xaf, 0xd7, 0x47, 0xd7, 0x4b, 0x07, 0x23, 0x4f, 0x23,
	0xe8, 0x65, 0x67, 0x9c, 0x0a, 0x55, 0x5b, 0x79, 0xb0, 0x5e, 0x2b, 0x90, 0x9d, 0xf1, 0x23, 0x15,
	0xbc, 0xfc, 0x1a, 0x41, 0xdf, 0x7b, 0xe1, 0xb2, 0x39, 0x97, 0xcf, 0xd7, 0x6b, 0x66, 0x2b, 0x3b,
	0xe3, 0x87, 0x32, 0x9c, 0xcc, 0xf0, 0x26, 0xb4, 0xac, 0x33, 0xe4, 0x1a, 0x6c, 0x4e, 0x59, 0x5e,
	0x35, 0x63, 0x50, 0x58, 0x0c, 0xf7, 0x61, 0x6b, 0xa1, 0x35, 0xfb, 0xf1, 0x02, 0x1f, 0x66, 0xb7,
	0x54, 0x20, 0xf7, 0x10, 0xac, 0x6f, 0x8f, 0xe1, 0x63, 0xe8, 0x2d, 0xb6, 0x07, 0x12, 0xc3, 0xe5,
	0x65, 0x7a, 0xb3, 0xfc, 0xf7, 0xb4, 0xb2, 0xf1, 0x7f, 0xd3, 0x4a, 0x6b, 0x79, 0x5a, 0x19, 0xfe,
	0x11, 0x01, 0xcc, 0x6f, 0x54, 0x2f, 0x25, 0xd5, 0xb8, 0xac, 0x14, 0x6f, 0xa4, 0xea, 0xa5, 0x9f,
	0x07, 0xca, 0xca, 0x85, 0x50, 0x18, 0xe6, 0x66, 0x6b, 0xf2, 0x0a, 0xec, 0xa4, 0x65, 0x51, 0x94,
	0x8a, 0x4a, 0x45, 0x03, 0xa5, 0x1e, 0xe7, 0x02, 0x7c, 0xac, 0xee, 0x22, 0x6f, 0x0f, 0x76, 0x6b,
	0x5e, 0x59, 0xb9, 0x9a, 0x78, 0x29, 0x0c, 0x6f, 0x01, 0xff, 0xb2, 0x72, 0xc8, 0x1c, 0xfe, 0xb5,
	0x51, 0x0f, 0x51, 0x0b, 0xd7, 0x3d, 0x39, 0x5b, 0x34, 0xe7, 0xfb, 0xf3, 0xb7, 0xab, 0xcb, 0xb7,
	0x75, 0x66, 0xbe, 0xf7, 0x8b, 0xa5, 0xbd, 0xaf, 0x41, 0x79, 0x7e, 0xb4, 0x15, 0xb4, 0xc3, 0xd1,
	0xc4, 0xad, 0x75, 0x08, 0xd7, 0x62, 0xbe, 0x6c, 0x17, 0xda, 0x9b, 0xaf, 0xb3, 0xba, 0xe4, 0x02,
	0x80, 0xe7, 0xdf, 0x4b, 0x7a, 0x35, 0x78, 0xe0, 0xb1, 0xe1, 0xb3, 0x08, 0x60, 0xde, 0x90, 0xc8,
	0x75, 0x68, 0x0b, 0x85, 0xd3, 0x65, 0x84, 0x77, 0x7c, 0xbd, 0x22, 0x23, 0xb8, 0xca, 0x72, 0xdf,
	0x02, 0xb8, 0xc8, 0x58, 0x95, 0x3b, 0x8a, 0xb5, 0x88, 0x35, 0xd5, 0x49, 0xae, 0x60, 0xe8, 0x30,
	0x44, 0x12, 0x1f, 0xf0, 0xc5, 0x15, 0xf8, 0x56, 0xe4, 0x19, 0xd5, 0x52, 0x85, 0x22, 0xee, 0x24,
	0x7d, 0x84, 0x4f, 0x44, 0x9e, 0x3d, 0x94, 0x6a, 0x42, 0x08, 0x5c, 0x2a, 0x4a, 0x2e, 0xea, 0x82,
	0xc2, 0xe7, 0xe1, 0x77, 0x00, 0x75, 0x9f, 0xe2, 0xd2, 0xfc, 0xa7, 0xa3, 0xeb, 0xd0, 0xb6, 0x65,
	0x65, 0xd2, 0xc6, 0x44, 0xbd, 0xf2, 0x43, 0x32, 0x17, 0xd6, 0x49, 0xc5, 0x9c, 0xc4, 0x04, 0xe0,
	0xe0, 0xb9, 0x00, 0x0d, 0x9f, 0x6e, 0x40, 0x7f, 0xa9, 0x11, 0x92, 0xef, 0x61, 0x53, 0x2a, 0x5d,
	0x39, 0x94, 0x58, 0x69, 0xef, 0x9f, 0x6f, 0x2c, 0x09, 0x92, 0xe4, 0x07, 0x68, 0x97, 0x95, 0xf3,
	0xe2, 0x1b, 0x6b, 0x14, 0xaf, 0x35, 0x87, 0x3b, 0xd0, 0x5f, 0xba, 0x24, 0xc7, 0x6d, 0xfc, 0x9f,
	0xf4, 0xd6, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x66, 0x94, 0x04, 0x08, 0xab, 0x0e, 0x00, 0x00,
}
